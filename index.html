<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.60);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: #fff;
            text-align: center;
            padding: 40px;
        }
        .start-screen.hidden {
            display: none;
        }
        .start-content {
            max-width: 600px;
            background: rgba(20, 20, 20, 0.60);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .start-title {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 30px;
            color: #4a9eff;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
        }
        .start-warning {
            background: rgba(255, 100, 100, 0.15);
            border: 2px solid rgba(255, 100, 100, 0.5);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            font-size: 16px;
            line-height: 1.6;
        }
        .start-warning strong {
            color: #ff6464;
            font-size: 18px;
            display: block;
            margin-bottom: 10px;
        }
        .start-credits {
            margin-bottom: 40px;
            font-size: 14px;
            color: #aaa;
            line-height: 1.8;
        }
        .start-credits strong {
            color: #fff;
            font-size: 16px;
        }
        .start-button {
            background: #4a9eff;
            border: none;
            color: white;
            padding: 18px 50px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.4);
        }
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 158, 255, 0.6);
        }
        .start-button:active {
            transform: translateY(0);
        }
        .canvas-hidden {
            display: none;
        }
        .controls-hidden {
            display: none;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.60);
            padding: 20px;
            border-radius: 8px;
            color: #fff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            max-height: 90vh;
            overflow-y: auto;
            width: 380px;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            transition: width 0.3s ease, height 0.3s ease;
        }
        .controls.minimized {
            width: 380px;
            height: auto;
            overflow: hidden;
        }
        .controls.minimized .section,
        .controls.minimized .info {
            display: none;
        }
        .minimize-btn {
            background: transparent;
            border: none;
            color: #aaa;
            padding: 0;
            margin: 0;
            cursor: pointer;
            font-size: 18px;
            font-weight: 300;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
            line-height: 1;
        }
        .minimize-btn:hover {
            color: #fff;
        }
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .controls::-webkit-scrollbar {
            width: 6px;
        }
        .controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        .controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        h3 {
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            min-width: 0;
        }
        h3 > span:first-of-type {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .stats {
            font-size: 11px;
            color: #888;
            font-weight: normal;
            flex-shrink: 0;
            white-space: nowrap;
        }
        .section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .section:last-child {
            border-bottom: none;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #ccc;
            font-weight: 500;
        }
        .value-display {
            color: #4a9eff;
            font-weight: 600;
            float: right;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #5aaeff;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
        }
        select option {
            background: #1a1a1a;
            color: #fff;
        }
        button {
            background: #4a9eff;
            border: none;
            padding: 10px 16px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
            font-weight: 500;
        }
        button:hover {
            background: #3a8eef;
            transform: translateY(-1px);
        }
        button.active {
            background: #2a7edf;
        }
        .color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 3px;
            display: inline-block;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s;
            position: relative;
        }
        .color-btn:hover {
            transform: scale(1.15);
        }
        .color-btn.active {
            border-color: white;
            transform: scale(1.1);
        }
        .color-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .color-btn.active::after {
            opacity: 1;
        }
        .info {
            font-size: 11px;
            color: #888;
            margin-top: 15px;
            line-height: 1.6;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .button-group button {
            margin: 0;
            flex: 1;
            min-width: calc(50% - 3px);
        }
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            background: transparent;
        }
        .color-picker-wrapper {
            margin-top: 10px;
        }
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .preset-grid button {
            margin: 0;
        }
        .section-title {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .section-title::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.2s;
        }
        .section.collapsed .section-title::after {
            transform: rotate(-90deg);
        }
        .section-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .section.collapsed .section-content {
            max-height: 0;
            margin-bottom: 0;
        }
        .section:not(.collapsed) .section-content {
            max-height: 5000px;
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-content">
            <h1 class="start-title">Particle Sandbox</h1>
            <div class="start-warning">
                <strong>Performance Warning</strong>
                This application is computationally intensive and may not run well on low-end PCs. High particle counts, weather effects, and VHS filters can cause significant performance issues.
            </div>
            <div class="start-credits">
                <strong>Created by empty? / emptyforce</strong><br>
                An interactive particle physics sandbox with advanced particle interactions.
            </div>
            <button class="start-button" onclick="startApplication()">Start</button>
        </div>
    </div>
    <canvas id="canvas" class="canvas-hidden"></canvas>
    <div class="controls controls-hidden" id="controlsPanel">
        <div class="controls-header">
            <h3><span>Particle Sandbox</span> <span class="stats" id="stats">0 particles | 60 FPS</span></h3>
            <button class="minimize-btn" id="minimizeBtn" onclick="toggleMinimize()">−</button>
        </div>
        
        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Spawn</div>
            <div class="section-content">
            <div class="control-group">
                <label>Mode: <span class="value-display" id="modeValue">Click & Drag</span></label>
                <select id="mode">
                    <option value="click">Click & Drag</option>
                    <option value="auto">Auto Spawn</option>
                    <option value="explosion">Explosion</option>
                    <option value="fountain">Fountain</option>
                    <option value="spiral">Spiral</option>
                    <option value="rain">Rain</option>
                </select>
            </div>
            <div class="control-group">
                <label>Particle Count: <span class="value-display" id="countValue">20</span></label>
                <input type="range" id="count" min="1" max="200" value="20">
            </div>
            <div class="control-group">
                <label>Speed: <span class="value-display" id="speedValue">1.0</span></label>
                <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1.0">
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Particle</div>
            <div class="section-content">
            <div class="control-group">
                <label>Size: <span class="value-display" id="sizeValue">3</span></label>
                <input type="range" id="size" min="1" max="20" value="3">
            </div>
            <div class="control-group">
                <label>Lifetime: <span class="value-display" id="lifetimeValue">100</span>%</label>
                <input type="range" id="lifetime" min="10" max="200" value="100">
            </div>
            <div class="control-group">
                <label>Trail Length: <span class="value-display" id="trailValue">5</span></label>
                <input type="range" id="trail" min="0" max="20" value="5">
            </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Physics</div>
            <div class="section-content">
            <div class="control-group">
                <label>Gravity: <span class="value-display" id="gravityValue">0.1</span></label>
                <input type="range" id="gravity" min="0" max="1" step="0.05" value="0.1">
            </div>
            <div class="control-group">
                <label>Friction: <span class="value-display" id="frictionValue">0.99</span></label>
                <input type="range" id="friction" min="0.85" max="1" step="0.01" value="0.99">
            </div>
            <div class="control-group">
                <label>Interaction: <span class="value-display" id="interactionValue">0.5</span></label>
                <input type="range" id="interaction" min="0" max="3" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>Mouse Force: <span class="value-display" id="mouseForceValue">1.0</span></label>
                <input type="range" id="mouseForce" min="0" max="5" step="0.1" value="1.0">
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Visual</div>
            <div class="section-content">
            <div class="control-group">
                <label>Shape: <span class="value-display" id="shapeValue">Circle</span></label>
                <select id="shape">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="triangle">Triangle</option>
                    <option value="star">Star</option>
                    <option value="line">Line</option>
                </select>
            </div>
            <div class="control-group">
                <label>Size Variation: <span class="value-display" id="sizeVarValue">50</span>%</label>
                <input type="range" id="sizeVar" min="0" max="100" value="50">
            </div>
            <div class="control-group">
                <label>Connection Distance: <span class="value-display" id="distanceValue">100</span></label>
                <input type="range" id="distance" min="0" max="300" value="100">
            </div>
            <div class="control-group">
                <label>Trail Opacity: <span class="value-display" id="trailOpacityValue">0.3</span></label>
                <input type="range" id="trailOpacity" min="0" max="1" step="0.05" value="0.3">
            </div>
            <div class="control-group">
                <label>Background: <span class="value-display" id="bgValue">Dark</span></label>
                <select id="background">
                    <option value="dark">Dark</option>
                    <option value="black">Black</option>
                    <option value="gray">Gray</option>
                </select>
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Advanced Physics</div>
            <div class="section-content">
            <div class="control-group">
                <label>Wind X: <span class="value-display" id="windXValue">0.0</span></label>
                <input type="range" id="windX" min="-2" max="2" step="0.1" value="0">
            </div>
            <div class="control-group">
                <label>Wind Y: <span class="value-display" id="windYValue">0.0</span></label>
                <input type="range" id="windY" min="-2" max="2" step="0.1" value="0">
            </div>
            <div class="control-group">
                <label>Collisions: <span class="value-display" id="collisionValue">OFF</span></label>
                <select id="collisions">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Bounce: <span class="value-display" id="bounceValue">0.8</span></label>
                <input type="range" id="bounce" min="0" max="1" step="0.1" value="0.8">
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Emitter</div>
            <div class="section-content">
            <div class="control-group">
                <label>Emitter: <span class="value-display" id="emitterValue">OFF</span></label>
                <select id="emitter">
                    <option value="off">OFF</option>
                    <option value="mouse">Mouse</option>
                    <option value="center">Center</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <div class="control-group">
                <label>Emit Rate: <span class="value-display" id="emitRateValue">5</span></label>
                <input type="range" id="emitRate" min="1" max="50" value="5">
            </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Colors</div>
            <div class="section-content">
            <div class="control-group">
                <label>Color Mode: <span class="value-display" id="colorModeValue">Single</span></label>
                <select id="colorMode">
                    <option value="single">Single</option>
                    <option value="random">Random</option>
                    <option value="gradient">Gradient</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="age">Age-based</option>
                    <option value="velocity">Velocity-based</option>
                </select>
            </div>
            <div class="control-group">
                <label>Custom Color:</label>
                <div class="color-picker-wrapper">
                    <input type="color" id="customColor" value="#4a9eff">
                </div>
            </div>
            <div id="colorPalette"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Field Forces</div>
            <div class="section-content">
            <div class="control-group">
                <label>Magnetic Field: <span class="value-display" id="magneticValue">0.0</span></label>
                <input type="range" id="magnetic" min="0" max="5" step="0.1" value="0">
            </div>
            <div class="control-group">
                <label>Vortex Strength: <span class="value-display" id="vortexValue">0.0</span></label>
                <input type="range" id="vortex" min="0" max="5" step="0.1" value="0">
            </div>
            <div class="control-group">
                <label>Noise: <span class="value-display" id="noiseValue">0.0</span></label>
                <input type="range" id="noise" min="0" max="2" step="0.1" value="0">
            </div>
            <div class="control-group">
                <label>Flocking: <span class="value-display" id="flockingValue">OFF</span></label>
                <select id="flocking">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Particle Aging</div>
            <div class="section-content">
            <div class="control-group">
                <label>Size Over Lifetime: <span class="value-display" id="sizeOverLifeValue">OFF</span></label>
                <select id="sizeOverLife">
                    <option value="off">OFF</option>
                    <option value="shrink">Shrink</option>
                    <option value="grow">Grow</option>
                    <option value="pulse">Pulse</option>
                </select>
            </div>
            <div class="control-group">
                <label>Color Over Lifetime: <span class="value-display" id="colorOverLifeValue">OFF</span></label>
                <select id="colorOverLife">
                    <option value="off">OFF</option>
                    <option value="fade">Fade</option>
                    <option value="shift">Color Shift</option>
                    <option value="heat">Heat Map</option>
                </select>
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Rendering</div>
            <div class="section-content">
            <div class="control-group">
                <label>Blend Mode: <span class="value-display" id="blendValue">Normal</span></label>
                <select id="blendMode">
                    <option value="normal">Normal</option>
                    <option value="screen">Screen</option>
                    <option value="multiply">Multiply</option>
                    <option value="overlay">Overlay</option>
                    <option value="lighten">Lighten</option>
                    <option value="darken">Darken</option>
                </select>
            </div>
            <div class="control-group">
                <label>Show Velocity: <span class="value-display" id="velocityVizValue">OFF</span></label>
                <select id="velocityViz">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Max Particles: <span class="value-display" id="maxParticlesValue">10000</span></label>
                <input type="range" id="maxParticles" min="100" max="50000" step="100" value="10000">
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">VHS / Retro Effects</div>
            <div class="section-content">
            <div class="control-group">
                <label>VHS Mode: <span class="value-display" id="vhsModeValue">OFF</span></label>
                <select id="vhsMode">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Scanlines: <span class="value-display" id="scanlinesValue">0</span>%</label>
                <input type="range" id="scanlines" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Chromatic Aberration: <span class="value-display" id="chromaticValue">0</span></label>
                <input type="range" id="chromatic" min="0" max="10" step="0.5" value="0">
            </div>
            <div class="control-group">
                <label>Film Grain: <span class="value-display" id="grainValue">0</span>%</label>
                <input type="range" id="grain" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>VHS Tracking: <span class="value-display" id="trackingValue">0</span>%</label>
                <input type="range" id="tracking" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Static Noise: <span class="value-display" id="staticValue">0</span>%</label>
                <input type="range" id="static" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Color Bleed: <span class="value-display" id="bleedValue">0</span>%</label>
                <input type="range" id="bleed" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>CRT Curvature: <span class="value-display" id="curvatureValue">0</span>%</label>
                <input type="range" id="curvature" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>VHS Glitch: <span class="value-display" id="glitchValue">0</span>%</label>
                <input type="range" id="glitch" min="0" max="100" value="0">
            </div>
            </div>
        </div>
        
        <div class="section collapsed">
            <div class="section-title" onclick="toggleSection(this)">Weather</div>
            <div class="section-content">
            <div class="control-group">
                <label>Tornado: <span class="value-display" id="tornadoEnabledValue">OFF</span></label>
                <select id="tornadoEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Tornado Strength: <span class="value-display" id="tornadoStrengthValue">5.0</span></label>
                <input type="range" id="tornadoStrength" min="1" max="10" step="0.5" value="5.0">
            </div>
            <div class="control-group">
                <label>Tornado Speed: <span class="value-display" id="tornadoSpeedValue">2.0</span></label>
                <input type="range" id="tornadoSpeed" min="0.5" max="5" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label>Tornado Size: <span class="value-display" id="tornadoSizeValue">150</span></label>
                <input type="range" id="tornadoSize" min="50" max="300" step="10" value="150">
            </div>
            <div class="control-group">
                <label>Tsunami: <span class="value-display" id="tsunamiEnabledValue">OFF</span></label>
                <select id="tsunamiEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Tsunami Strength: <span class="value-display" id="tsunamiStrengthValue">3.0</span></label>
                <input type="range" id="tsunamiStrength" min="1" max="10" step="0.5" value="3.0">
            </div>
            <div class="control-group">
                <label>Tsunami Speed: <span class="value-display" id="tsunamiSpeedValue">2.0</span></label>
                <input type="range" id="tsunamiSpeed" min="0.5" max="5" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label>Tsunami Size: <span class="value-display" id="tsunamiSizeValue">150</span></label>
                <input type="range" id="tsunamiSize" min="50" max="300" step="10" value="150">
            </div>
            <div class="control-group">
                <label>Volcano: <span class="value-display" id="volcanoEnabledValue">OFF</span></label>
                <select id="volcanoEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Volcano Intensity: <span class="value-display" id="volcanoIntensityValue">5.0</span></label>
                <input type="range" id="volcanoIntensity" min="1" max="10" step="0.5" value="5.0">
            </div>
            <div class="control-group">
                <label>Volcano Speed: <span class="value-display" id="volcanoSpeedValue">1.0</span></label>
                <input type="range" id="volcanoSpeed" min="0.5" max="5" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Volcano Size: <span class="value-display" id="volcanoSizeValue">200</span></label>
                <input type="range" id="volcanoSize" min="50" max="400" step="10" value="200">
            </div>
            <div class="control-group">
                <label>Thunder: <span class="value-display" id="thunderEnabledValue">OFF</span></label>
                <select id="thunderEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Thunder Frequency: <span class="value-display" id="thunderFreqValue">2.0</span></label>
                <input type="range" id="thunderFreq" min="0.5" max="5" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label>Thunder Strength: <span class="value-display" id="thunderStrengthValue">5.0</span></label>
                <input type="range" id="thunderStrength" min="1" max="10" step="0.5" value="5.0">
            </div>
            <div class="control-group">
                <label>Thunder Size: <span class="value-display" id="thunderSizeValue">100</span></label>
                <input type="range" id="thunderSize" min="50" max="300" step="10" value="100">
            </div>
            <div class="control-group">
                <label>Rain: <span class="value-display" id="rainEnabledValue">OFF</span></label>
                <select id="rainEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Rain Intensity: <span class="value-display" id="rainIntensityValue">3.0</span></label>
                <input type="range" id="rainIntensity" min="1" max="10" step="0.5" value="3.0">
            </div>
            <div class="control-group">
                <label>Rain Speed: <span class="value-display" id="rainSpeedValue">3.0</span></label>
                <input type="range" id="rainSpeed" min="0.5" max="8" step="0.1" value="3.0">
            </div>
            <div class="control-group">
                <label>Rain Size: <span class="value-display" id="rainSizeValue">15</span></label>
                <input type="range" id="rainSize" min="5" max="30" step="1" value="15">
            </div>
            <div class="control-group">
                <label>Snow: <span class="value-display" id="snowEnabledValue">OFF</span></label>
                <select id="snowEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Snow Intensity: <span class="value-display" id="snowIntensityValue">2.0</span></label>
                <input type="range" id="snowIntensity" min="1" max="10" step="0.5" value="2.0">
            </div>
            <div class="control-group">
                <label>Snow Speed: <span class="value-display" id="snowSpeedValue">1.0</span></label>
                <input type="range" id="snowSpeed" min="0.3" max="3" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Snow Size: <span class="value-display" id="snowSizeValue">3</span></label>
                <input type="range" id="snowSize" min="1" max="8" step="0.5" value="3">
            </div>
            <div class="control-group">
                <label>Hurricane: <span class="value-display" id="hurricaneEnabledValue">OFF</span></label>
                <select id="hurricaneEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Hurricane Strength: <span class="value-display" id="hurricaneStrengthValue">6.0</span></label>
                <input type="range" id="hurricaneStrength" min="1" max="10" step="0.5" value="6.0">
            </div>
            <div class="control-group">
                <label>Hurricane Speed: <span class="value-display" id="hurricaneSpeedValue">0.5</span></label>
                <input type="range" id="hurricaneSpeed" min="0.1" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label>Hurricane Size: <span class="value-display" id="hurricaneSizeValue">300</span></label>
                <input type="range" id="hurricaneSize" min="100" max="600" step="20" value="300">
            </div>
            <div class="control-group">
                <label>Earthquake: <span class="value-display" id="earthquakeEnabledValue">OFF</span></label>
                <select id="earthquakeEnabled">
                    <option value="off">OFF</option>
                    <option value="on">ON</option>
                </select>
            </div>
            <div class="control-group">
                <label>Earthquake Intensity: <span class="value-display" id="earthquakeIntensityValue">3.0</span></label>
                <input type="range" id="earthquakeIntensity" min="1" max="10" step="0.5" value="3.0">
            </div>
            <div class="control-group">
                <label>Earthquake Speed: <span class="value-display" id="earthquakeSpeedValue">1.0</span></label>
                <input type="range" id="earthquakeSpeed" min="0.5" max="3" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Earthquake Range: <span class="value-display" id="earthquakeRangeValue">100</span></label>
                <input type="range" id="earthquakeRange" min="50" max="300" step="10" value="100">
            </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Presets</div>
            <div class="section-content">
            <div class="preset-grid">
                <button onclick="loadPreset('fireworks')">Fireworks</button>
                <button onclick="loadPreset('galaxy')">Galaxy</button>
                <button onclick="loadPreset('plasma')">Plasma</button>
                <button onclick="loadPreset('vortex')">Vortex</button>
                <button onclick="loadPreset('flocking')">Flocking</button>
                <button onclick="loadPreset('magnetic')">Magnetic</button>
                <button onclick="loadPreset('chaos')">Chaos</button>
                <button onclick="loadPreset('nebula')">Nebula</button>
                <button onclick="loadPreset('stars')">Stars</button>
                <button onclick="loadPreset('smoke')">Smoke</button>
                <button onclick="loadPreset('bubbles')">Bubbles</button>
                <button onclick="loadPreset('sparkles')">Sparkles</button>
                <button onclick="loadPreset('aurora')">Aurora</button>
                <button onclick="loadPreset('energy')">Energy</button>
            </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Save/Load</div>
            <div class="section-content">
            <div class="button-group">
                <button onclick="saveConfig()">Save Config</button>
                <button onclick="loadConfig()">Load Config</button>
            </div>
            <div class="button-group">
                <button onclick="exportImage()">Export Image</button>
                <button onclick="exportGIF()">Export GIF</button>
            </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title" onclick="toggleSection(this)">Controls</div>
            <div class="section-content">
            <div class="button-group">
                <button id="physicsBtn" onclick="togglePhysics()">Physics: ON</button>
                <button id="connectionsBtn" onclick="toggleConnections()">Connections: ON</button>
            </div>
            <div class="button-group">
                <button onclick="clearParticles()">Clear</button>
                <button onclick="resetSettings()">Reset</button>
            </div>
            <div class="button-group">
                <button id="devModeBtn" onclick="toggleDevMode()" style="background: #ff4444; color: white;">Dev Mode: OFF</button>
            </div>
            </div>
        </div>

        <div class="info">
            Left-click: Spawn particles<br>
            Drag: Create trails<br>
            Right-click: Repel particles<br>
            Middle-click: Attract particles
        </div>
        </div>
    </div>

    <script>
        // Declare all variables first
        let particles = [];
        let vhsCanvas = null;
        let vhsCtx = null;
        let mouseDown = false;
        let rightMouseDown = false;
        let middleMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let particleSize = 3;
        let gravity = 0.1;
        let friction = 0.99;
        let interactionForce = 0.5;
        let connectionDistance = 100;
        let physicsEnabled = true;
        let connectionsEnabled = true;
        let currentColor = '#4a9eff';
        let mode = 'click';
        let particleCount = 20;
        let autoSpawnTimer = 0;
        let speed = 1.0;
        let lifetime = 100;
        let trailLength = 5;
        let trailOpacity = 0.3;
        let mouseForce = 1.0;
        let backgroundMode = 'dark';
        let lastTime = performance.now();
        let fps = 60;
        let frameCount = 0;
        let fpsTimer = 0;
        let particleShape = 'circle';
        let sizeVariation = 50;
        let windX = 0;
        let windY = 0;
        let collisionsEnabled = false;
        let bounce = 0.8;
        let emitterMode = 'off';
        let emitRate = 5;
        let emitTimer = 0;
        let colorMode = 'single';
        let emitterX = 0;
        let emitterY = 0;
        let magneticField = 0;
        let vortexStrength = 0;
        let noiseAmount = 0;
        let flockingEnabled = false;
        let sizeOverLife = 'off';
        let colorOverLife = 'off';
        let blendMode = 'normal';
        let velocityViz = false;
        let maxParticles = 10000;
        let customColorInput = null;
        let attractors = [];
        let repellers = [];
        let gifFrames = [];
        let gifRecording = false;
        let gifFrameCount = 0;
        let vhsMode = false;
        let scanlinesIntensity = 0;
        let chromaticAberration = 0;
        let filmGrain = 0;
        let vhsTracking = 0;
        let staticNoise = 0;
        let colorBleed = 0;
        let crtCurvature = 0;
        let vhsGlitch = 0;
        let glitchTimer = 0;
        let devMode = false;
        let tornadoEnabled = false;
        let tornadoStrength = 5.0;
        let tornadoSpeed = 2.0;
        let tornadoSize = 150;
        let tornado = null;
        let tsunamiEnabled = false;
        let tsunamiStrength = 3.0;
        let tsunamiSpeed = 2.0;
        let tsunamiSize = 150;
        let tsunamiWaves = [];
        let volcanoEnabled = false;
        let volcanoIntensity = 5.0;
        let volcanoSpeed = 1.0;
        let volcanoSize = 200;
        let volcano = null;
        let thunderEnabled = false;
        let thunderFreq = 2.0;
        let thunderStrength = 5.0;
        let thunderSize = 100;
        let thunderTimer = 0;
        let lightningStrikes = [];
        let thunderFlash = 0;
        let thunderShake = { x: 0, y: 0 };
        let rainEnabled = false;
        let rainIntensity = 3.0;
        let rainSpeed = 3.0;
        let rainSize = 15;
        let rainDrops = [];
        let snowEnabled = false;
        let snowIntensity = 2.0;
        let snowSpeed = 1.0;
        let snowSize = 3;
        let snowFlakes = [];
        let hurricaneEnabled = false;
        let hurricaneStrength = 6.0;
        let hurricaneSpeed = 0.5;
        let hurricaneSize = 300;
        let hurricane = null;
        let earthquakeEnabled = false;
        let earthquakeIntensity = 3.0;
        let earthquakeSpeed = 1.0;
        let earthquakeRange = 100;
        let earthquakeTimer = 0;
        let earthquakeShake = { x: 0, y: 0 };

        let applicationStarted = false;

        // Initialize canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        vhsCanvas = document.createElement('canvas');
        vhsCtx = vhsCanvas.getContext('2d');

        function startApplication() {
            const startScreen = document.getElementById('startScreen');
            const canvas = document.getElementById('canvas');
            const controls = document.getElementById('controlsPanel');
            
            localStorage.setItem('particleSandbox_warningSeen', 'true');
            
            startScreen.classList.add('hidden');
            canvas.classList.remove('canvas-hidden');
            controls.classList.remove('controls-hidden');
            
            applicationStarted = true;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            vhsCanvas.width = canvas.width;
            vhsCanvas.height = canvas.height;
            
            animate(performance.now());
        }

        function checkWarningSeen() {
            const warningSeen = localStorage.getItem('particleSandbox_warningSeen');
            if (warningSeen === 'true') {
                const startScreen = document.getElementById('startScreen');
                const canvas = document.getElementById('canvas');
                const controls = document.getElementById('controlsPanel');
                
                startScreen.classList.add('hidden');
                canvas.classList.remove('canvas-hidden');
                controls.classList.remove('controls-hidden');
                
                applicationStarted = true;
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                vhsCanvas.width = canvas.width;
                vhsCanvas.height = canvas.height;
                
                animate(performance.now());
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            checkWarningSeen();
        });

        const colors = [
            '#4a9eff', '#ff4a9e', '#4aff9e', '#ffff4a', 
            '#ff4a4a', '#9e4aff', '#ffffff', '#ff9e4a',
            '#00ff88', '#ff0088', '#8800ff', '#ff8800'
        ];
        
        const palette = document.getElementById('colorPalette');
        colors.forEach((color, index) => {
            const btn = document.createElement('div');
            btn.className = 'color-btn' + (index === 0 ? ' active' : '');
            btn.style.background = color;
            btn.onclick = () => {
                currentColor = color;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
            palette.appendChild(btn);
        });

        function updateStats() {
            document.getElementById('stats').textContent = `${particles.length} particles | ${Math.round(fps)} FPS`;
        }

        document.getElementById('size').oninput = (e) => {
            particleSize = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = particleSize;
        };

        document.getElementById('gravity').oninput = (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = gravity.toFixed(2);
        };

        document.getElementById('friction').oninput = (e) => {
            friction = parseFloat(e.target.value);
            document.getElementById('frictionValue').textContent = friction.toFixed(2);
        };

        document.getElementById('interaction').oninput = (e) => {
            interactionForce = parseFloat(e.target.value);
            document.getElementById('interactionValue').textContent = interactionForce.toFixed(1);
        };

        document.getElementById('distance').oninput = (e) => {
            connectionDistance = parseInt(e.target.value);
            document.getElementById('distanceValue').textContent = connectionDistance;
        };

        document.getElementById('count').oninput = (e) => {
            particleCount = parseInt(e.target.value);
            document.getElementById('countValue').textContent = particleCount;
        };

        document.getElementById('speed').oninput = (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = speed.toFixed(1);
        };

        document.getElementById('lifetime').oninput = (e) => {
            lifetime = parseInt(e.target.value);
            document.getElementById('lifetimeValue').textContent = lifetime + '%';
        };

        document.getElementById('trail').oninput = (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailValue').textContent = trailLength;
        };

        document.getElementById('trailOpacity').oninput = (e) => {
            trailOpacity = parseFloat(e.target.value);
            document.getElementById('trailOpacityValue').textContent = trailOpacity.toFixed(2);
        };

        document.getElementById('mouseForce').oninput = (e) => {
            mouseForce = parseFloat(e.target.value);
            document.getElementById('mouseForceValue').textContent = mouseForce.toFixed(1);
        };

        document.getElementById('mode').onchange = (e) => {
            mode = e.target.value;
            document.getElementById('modeValue').textContent = e.target.options[e.target.selectedIndex].text;
        };

        document.getElementById('background').onchange = (e) => {
            backgroundMode = e.target.value;
            document.getElementById('bgValue').textContent = e.target.options[e.target.selectedIndex].text;
        };

        document.getElementById('shape').onchange = (e) => {
            particleShape = e.target.value;
            document.getElementById('shapeValue').textContent = e.target.options[e.target.selectedIndex].text;
        };

        document.getElementById('sizeVar').oninput = (e) => {
            sizeVariation = parseInt(e.target.value);
            document.getElementById('sizeVarValue').textContent = sizeVariation + '%';
        };

        document.getElementById('windX').oninput = (e) => {
            windX = parseFloat(e.target.value);
            document.getElementById('windXValue').textContent = windX.toFixed(1);
        };

        document.getElementById('windY').oninput = (e) => {
            windY = parseFloat(e.target.value);
            document.getElementById('windYValue').textContent = windY.toFixed(1);
        };

        document.getElementById('collisions').onchange = (e) => {
            collisionsEnabled = e.target.value === 'on';
            document.getElementById('collisionValue').textContent = collisionsEnabled ? 'ON' : 'OFF';
        };

        document.getElementById('bounce').oninput = (e) => {
            bounce = parseFloat(e.target.value);
            document.getElementById('bounceValue').textContent = bounce.toFixed(1);
        };

        document.getElementById('emitter').onchange = (e) => {
            emitterMode = e.target.value;
            document.getElementById('emitterValue').textContent = e.target.options[e.target.selectedIndex].text.toUpperCase();
        };

        document.getElementById('emitRate').oninput = (e) => {
            emitRate = parseInt(e.target.value);
            document.getElementById('emitRateValue').textContent = emitRate;
        };

        document.getElementById('colorMode').onchange = (e) => {
            colorMode = e.target.value;
            document.getElementById('colorModeValue').textContent = e.target.options[e.target.selectedIndex].text;
        };

        document.getElementById('customColor').oninput = (e) => {
            currentColor = e.target.value;
            document.querySelectorAll('.color-btn').forEach(b => {
                if (b.style.background === currentColor) {
                    b.classList.add('active');
                } else {
                    b.classList.remove('active');
                }
            });
        };

        document.getElementById('magnetic').oninput = (e) => {
            magneticField = parseFloat(e.target.value);
            document.getElementById('magneticValue').textContent = magneticField.toFixed(1);
        };

        document.getElementById('vortex').oninput = (e) => {
            vortexStrength = parseFloat(e.target.value);
            document.getElementById('vortexValue').textContent = vortexStrength.toFixed(1);
        };

        document.getElementById('noise').oninput = (e) => {
            noiseAmount = parseFloat(e.target.value);
            document.getElementById('noiseValue').textContent = noiseAmount.toFixed(1);
        };

        document.getElementById('flocking').onchange = (e) => {
            flockingEnabled = e.target.value === 'on';
            document.getElementById('flockingValue').textContent = flockingEnabled ? 'ON' : 'OFF';
        };

        document.getElementById('sizeOverLife').onchange = (e) => {
            sizeOverLife = e.target.value;
            document.getElementById('sizeOverLifeValue').textContent = e.target.options[e.target.selectedIndex].text;
        };

        document.getElementById('colorOverLife').onchange = (e) => {
            colorOverLife = e.target.value;
            document.getElementById('colorOverLifeValue').textContent = e.target.options[e.target.selectedIndex].text;
        };

        document.getElementById('blendMode').onchange = (e) => {
            blendMode = e.target.value;
            document.getElementById('blendValue').textContent = e.target.options[e.target.selectedIndex].text;
            ctx.globalCompositeOperation = blendMode;
        };

        document.getElementById('velocityViz').onchange = (e) => {
            velocityViz = e.target.value === 'on';
            document.getElementById('velocityVizValue').textContent = velocityViz ? 'ON' : 'OFF';
        };

        document.getElementById('maxParticles').oninput = (e) => {
            maxParticles = parseInt(e.target.value);
            document.getElementById('maxParticlesValue').textContent = maxParticles;
        };

        document.getElementById('vhsMode').onchange = (e) => {
            vhsMode = e.target.value === 'on';
            document.getElementById('vhsModeValue').textContent = vhsMode ? 'ON' : 'OFF';
        };

        document.getElementById('scanlines').oninput = (e) => {
            scanlinesIntensity = parseInt(e.target.value);
            document.getElementById('scanlinesValue').textContent = scanlinesIntensity + '%';
        };

        document.getElementById('chromatic').oninput = (e) => {
            chromaticAberration = parseFloat(e.target.value);
            document.getElementById('chromaticValue').textContent = chromaticAberration.toFixed(1);
        };

        document.getElementById('grain').oninput = (e) => {
            filmGrain = parseInt(e.target.value);
            document.getElementById('grainValue').textContent = filmGrain + '%';
        };

        document.getElementById('tracking').oninput = (e) => {
            vhsTracking = parseInt(e.target.value);
            document.getElementById('trackingValue').textContent = vhsTracking + '%';
        };

        document.getElementById('static').oninput = (e) => {
            staticNoise = parseInt(e.target.value);
            document.getElementById('staticValue').textContent = staticNoise + '%';
        };

        document.getElementById('bleed').oninput = (e) => {
            colorBleed = parseInt(e.target.value);
            document.getElementById('bleedValue').textContent = colorBleed + '%';
        };

        document.getElementById('curvature').oninput = (e) => {
            crtCurvature = parseInt(e.target.value);
            document.getElementById('curvatureValue').textContent = crtCurvature + '%';
        };

        document.getElementById('glitch').oninput = (e) => {
            vhsGlitch = parseInt(e.target.value);
            document.getElementById('glitchValue').textContent = vhsGlitch + '%';
        };

        document.getElementById('tornadoEnabled').onchange = (e) => {
            tornadoEnabled = e.target.value === 'on';
            document.getElementById('tornadoEnabledValue').textContent = tornadoEnabled ? 'ON' : 'OFF';
            if (tornadoEnabled && !tornado) {
                tornado = {
                    x: canvas.width / 2,
                    y: canvas.height + 50,
                    rotation: 0,
                    path: [],
                    active: true
                };
            } else if (!tornadoEnabled) {
                tornado = null;
            }
        };

        document.getElementById('tornadoStrength').oninput = (e) => {
            tornadoStrength = parseFloat(e.target.value);
            document.getElementById('tornadoStrengthValue').textContent = tornadoStrength.toFixed(1);
        };

        document.getElementById('tornadoSpeed').oninput = (e) => {
            tornadoSpeed = parseFloat(e.target.value);
            document.getElementById('tornadoSpeedValue').textContent = tornadoSpeed.toFixed(1);
        };

        document.getElementById('tornadoSize').oninput = (e) => {
            tornadoSize = parseInt(e.target.value);
            document.getElementById('tornadoSizeValue').textContent = tornadoSize;
        };

        document.getElementById('tsunamiEnabled').onchange = (e) => {
            tsunamiEnabled = e.target.value === 'on';
            document.getElementById('tsunamiEnabledValue').textContent = tsunamiEnabled ? 'ON' : 'OFF';
            if (!tsunamiEnabled) tsunamiWaves = [];
        };

        document.getElementById('tsunamiStrength').oninput = (e) => {
            tsunamiStrength = parseFloat(e.target.value);
            document.getElementById('tsunamiStrengthValue').textContent = tsunamiStrength.toFixed(1);
        };

        document.getElementById('tsunamiSpeed').oninput = (e) => {
            tsunamiSpeed = parseFloat(e.target.value);
            document.getElementById('tsunamiSpeedValue').textContent = tsunamiSpeed.toFixed(1);
        };

        document.getElementById('tsunamiSize').oninput = (e) => {
            tsunamiSize = parseInt(e.target.value);
            document.getElementById('tsunamiSizeValue').textContent = tsunamiSize;
        };

        document.getElementById('volcanoEnabled').onchange = (e) => {
            volcanoEnabled = e.target.value === 'on';
            document.getElementById('volcanoEnabledValue').textContent = volcanoEnabled ? 'ON' : 'OFF';
            if (volcanoEnabled && !volcano) {
                volcano = {
                    x: canvas.width / 2,
                    y: canvas.height - 20,
                    eruptionTimer: 0,
                    active: true
                };
            } else if (!volcanoEnabled) {
                volcano = null;
            }
        };

        document.getElementById('volcanoIntensity').oninput = (e) => {
            volcanoIntensity = parseFloat(e.target.value);
            document.getElementById('volcanoIntensityValue').textContent = volcanoIntensity.toFixed(1);
        };

        document.getElementById('volcanoSpeed').oninput = (e) => {
            volcanoSpeed = parseFloat(e.target.value);
            document.getElementById('volcanoSpeedValue').textContent = volcanoSpeed.toFixed(1);
        };

        document.getElementById('volcanoSize').oninput = (e) => {
            volcanoSize = parseInt(e.target.value);
            document.getElementById('volcanoSizeValue').textContent = volcanoSize;
        };

        document.getElementById('thunderEnabled').onchange = (e) => {
            thunderEnabled = e.target.value === 'on';
            document.getElementById('thunderEnabledValue').textContent = thunderEnabled ? 'ON' : 'OFF';
            if (!thunderEnabled) lightningStrikes = [];
        };

        document.getElementById('thunderFreq').oninput = (e) => {
            thunderFreq = parseFloat(e.target.value);
            document.getElementById('thunderFreqValue').textContent = thunderFreq.toFixed(1);
        };

        document.getElementById('thunderStrength').oninput = (e) => {
            thunderStrength = parseFloat(e.target.value);
            document.getElementById('thunderStrengthValue').textContent = thunderStrength.toFixed(1);
        };

        document.getElementById('thunderSize').oninput = (e) => {
            thunderSize = parseInt(e.target.value);
            document.getElementById('thunderSizeValue').textContent = thunderSize;
        };

        document.getElementById('rainEnabled').onchange = (e) => {
            rainEnabled = e.target.value === 'on';
            document.getElementById('rainEnabledValue').textContent = rainEnabled ? 'ON' : 'OFF';
            if (!rainEnabled) rainDrops = [];
        };

        document.getElementById('rainIntensity').oninput = (e) => {
            rainIntensity = parseFloat(e.target.value);
            document.getElementById('rainIntensityValue').textContent = rainIntensity.toFixed(1);
        };

        document.getElementById('rainSpeed').oninput = (e) => {
            rainSpeed = parseFloat(e.target.value);
            document.getElementById('rainSpeedValue').textContent = rainSpeed.toFixed(1);
        };

        document.getElementById('rainSize').oninput = (e) => {
            rainSize = parseInt(e.target.value);
            document.getElementById('rainSizeValue').textContent = rainSize;
        };

        document.getElementById('snowEnabled').onchange = (e) => {
            snowEnabled = e.target.value === 'on';
            document.getElementById('snowEnabledValue').textContent = snowEnabled ? 'ON' : 'OFF';
            if (!snowEnabled) snowFlakes = [];
        };

        document.getElementById('snowIntensity').oninput = (e) => {
            snowIntensity = parseFloat(e.target.value);
            document.getElementById('snowIntensityValue').textContent = snowIntensity.toFixed(1);
        };

        document.getElementById('snowSpeed').oninput = (e) => {
            snowSpeed = parseFloat(e.target.value);
            document.getElementById('snowSpeedValue').textContent = snowSpeed.toFixed(1);
        };

        document.getElementById('snowSize').oninput = (e) => {
            snowSize = parseFloat(e.target.value);
            document.getElementById('snowSizeValue').textContent = snowSize.toFixed(1);
        };

        document.getElementById('hurricaneEnabled').onchange = (e) => {
            hurricaneEnabled = e.target.value === 'on';
            document.getElementById('hurricaneEnabledValue').textContent = hurricaneEnabled ? 'ON' : 'OFF';
            if (hurricaneEnabled && !hurricane) {
                hurricane = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    rotation: 0,
                    active: true
                };
            } else if (!hurricaneEnabled) {
                hurricane = null;
            }
        };

        document.getElementById('hurricaneStrength').oninput = (e) => {
            hurricaneStrength = parseFloat(e.target.value);
            document.getElementById('hurricaneStrengthValue').textContent = hurricaneStrength.toFixed(1);
        };

        document.getElementById('hurricaneSpeed').oninput = (e) => {
            hurricaneSpeed = parseFloat(e.target.value);
            document.getElementById('hurricaneSpeedValue').textContent = hurricaneSpeed.toFixed(1);
        };

        document.getElementById('hurricaneSize').oninput = (e) => {
            hurricaneSize = parseInt(e.target.value);
            document.getElementById('hurricaneSizeValue').textContent = hurricaneSize;
        };

        document.getElementById('earthquakeEnabled').onchange = (e) => {
            earthquakeEnabled = e.target.value === 'on';
            document.getElementById('earthquakeEnabledValue').textContent = earthquakeEnabled ? 'ON' : 'OFF';
            earthquakeShake = { x: 0, y: 0 };
        };

        document.getElementById('earthquakeIntensity').oninput = (e) => {
            earthquakeIntensity = parseFloat(e.target.value);
            document.getElementById('earthquakeIntensityValue').textContent = earthquakeIntensity.toFixed(1);
        };

        document.getElementById('earthquakeSpeed').oninput = (e) => {
            earthquakeSpeed = parseFloat(e.target.value);
            document.getElementById('earthquakeSpeedValue').textContent = earthquakeSpeed.toFixed(1);
        };

        document.getElementById('earthquakeRange').oninput = (e) => {
            earthquakeRange = parseInt(e.target.value);
            document.getElementById('earthquakeRangeValue').textContent = earthquakeRange;
        };

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            document.getElementById('physicsBtn').textContent = `Physics: ${physicsEnabled ? 'ON' : 'OFF'}`;
            document.getElementById('physicsBtn').classList.toggle('active', physicsEnabled);
        }

        function toggleConnections() {
            connectionsEnabled = !connectionsEnabled;
            document.getElementById('connectionsBtn').textContent = `Connections: ${connectionsEnabled ? 'ON' : 'OFF'}`;
            document.getElementById('connectionsBtn').classList.toggle('active', connectionsEnabled);
        }

        function toggleMinimize() {
            const panel = document.getElementById('controlsPanel');
            const btn = document.getElementById('minimizeBtn');
            panel.classList.toggle('minimized');
            btn.textContent = panel.classList.contains('minimized') ? '+' : '−';
        }

        function toggleSection(titleElement) {
            const section = titleElement.parentElement;
            section.classList.toggle('collapsed');
        }

        function setupValueDoubleClick(valueId, sliderId, setter, parser = parseInt, formatter = (v) => v) {
            const valueEl = document.getElementById(valueId);
            valueEl.style.cursor = devMode ? 'pointer' : 'default';
            valueEl.title = devMode ? 'Double-click to set value' : '';
            valueEl.ondblclick = () => {
                if (devMode) {
                    const current = parser(document.getElementById(sliderId).value);
                    const input = prompt(`Enter value:`, current);
                    if (input !== null) {
                        const val = parser(input);
                        if (!isNaN(val)) {
                            document.getElementById(sliderId).value = val;
                            setter(val);
                            valueEl.textContent = formatter(val);
                        }
                    }
                }
            };
        }

        function toggleDevMode() {
            devMode = !devMode;
            const btn = document.getElementById('devModeBtn');
            btn.textContent = `Dev Mode: ${devMode ? 'ON' : 'OFF'}`;
            btn.style.background = devMode ? '#44ff44' : '#ff4444';
            
            const unlimited = 999999999;
            
            if (devMode) {
                maxParticles = Infinity;
                document.getElementById('maxParticles').max = unlimited;
                document.getElementById('maxParticles').value = unlimited;
                document.getElementById('maxParticlesValue').textContent = 'UNLIMITED';
                
                document.getElementById('size').max = unlimited;
                document.getElementById('count').max = unlimited;
                document.getElementById('speed').max = unlimited;
                document.getElementById('lifetime').max = unlimited;
                document.getElementById('trail').max = unlimited;
                document.getElementById('gravity').max = unlimited;
                document.getElementById('friction').max = unlimited;
                document.getElementById('interaction').max = unlimited;
                document.getElementById('mouseForce').max = unlimited;
                document.getElementById('sizeVar').max = unlimited;
                document.getElementById('distance').max = unlimited;
                document.getElementById('trailOpacity').max = unlimited;
                document.getElementById('windX').max = unlimited;
                document.getElementById('windX').min = -unlimited;
                document.getElementById('windY').max = unlimited;
                document.getElementById('windY').min = -unlimited;
                document.getElementById('bounce').max = unlimited;
                document.getElementById('emitRate').max = unlimited;
                document.getElementById('magnetic').max = unlimited;
                document.getElementById('vortex').max = unlimited;
                document.getElementById('noise').max = unlimited;
                document.getElementById('scanlines').max = unlimited;
                document.getElementById('chromatic').max = unlimited;
                document.getElementById('grain').max = unlimited;
                document.getElementById('tracking').max = unlimited;
                document.getElementById('static').max = unlimited;
                document.getElementById('bleed').max = unlimited;
                document.getElementById('curvature').max = unlimited;
                document.getElementById('glitch').max = unlimited;
                
                setupValueDoubleClick('sizeValue', 'size', (v) => { particleSize = v; }, parseInt);
                setupValueDoubleClick('countValue', 'count', (v) => { particleCount = v; }, parseInt);
                setupValueDoubleClick('speedValue', 'speed', (v) => { speed = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('lifetimeValue', 'lifetime', (v) => { lifetime = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('trailValue', 'trail', (v) => { trailLength = v; }, parseInt);
                setupValueDoubleClick('gravityValue', 'gravity', (v) => { gravity = v; }, parseFloat, (v) => v.toFixed(2));
                setupValueDoubleClick('frictionValue', 'friction', (v) => { friction = v; }, parseFloat, (v) => v.toFixed(2));
                setupValueDoubleClick('interactionValue', 'interaction', (v) => { interactionForce = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('mouseForceValue', 'mouseForce', (v) => { mouseForce = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('sizeVarValue', 'sizeVar', (v) => { sizeVariation = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('distanceValue', 'distance', (v) => { connectionDistance = v; }, parseInt);
                setupValueDoubleClick('trailOpacityValue', 'trailOpacity', (v) => { trailOpacity = v; }, parseFloat, (v) => v.toFixed(2));
                setupValueDoubleClick('windXValue', 'windX', (v) => { windX = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('windYValue', 'windY', (v) => { windY = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('bounceValue', 'bounce', (v) => { bounce = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('emitRateValue', 'emitRate', (v) => { emitRate = v; }, parseInt);
                setupValueDoubleClick('magneticValue', 'magnetic', (v) => { magneticField = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('vortexValue', 'vortex', (v) => { vortexStrength = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('noiseValue', 'noise', (v) => { noiseAmount = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('scanlinesValue', 'scanlines', (v) => { scanlinesIntensity = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('chromaticValue', 'chromatic', (v) => { chromaticAberration = v; }, parseFloat, (v) => v.toFixed(1));
                setupValueDoubleClick('grainValue', 'grain', (v) => { filmGrain = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('trackingValue', 'tracking', (v) => { vhsTracking = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('staticValue', 'static', (v) => { staticNoise = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('bleedValue', 'bleed', (v) => { colorBleed = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('curvatureValue', 'curvature', (v) => { crtCurvature = v; }, parseInt, (v) => v + '%');
                setupValueDoubleClick('glitchValue', 'glitch', (v) => { vhsGlitch = v; }, parseInt, (v) => v + '%');
            } else {
                maxParticles = 10000;
                document.getElementById('maxParticles').max = 50000;
                document.getElementById('maxParticles').value = 10000;
                document.getElementById('maxParticlesValue').textContent = '10000';
                
                document.getElementById('size').max = 20;
                document.getElementById('count').max = 200;
                document.getElementById('speed').max = 5;
                document.getElementById('lifetime').max = 200;
                document.getElementById('trail').max = 20;
                document.getElementById('gravity').max = 1;
                document.getElementById('friction').max = 1;
                document.getElementById('interaction').max = 3;
                document.getElementById('mouseForce').max = 5;
                document.getElementById('sizeVar').max = 100;
                document.getElementById('distance').max = 300;
                document.getElementById('trailOpacity').max = 1;
                document.getElementById('windX').max = 2;
                document.getElementById('windX').min = -2;
                document.getElementById('windY').max = 2;
                document.getElementById('windY').min = -2;
                document.getElementById('bounce').max = 1;
                document.getElementById('emitRate').max = 50;
                document.getElementById('magnetic').max = 5;
                document.getElementById('vortex').max = 5;
                document.getElementById('noise').max = 2;
                document.getElementById('scanlines').max = 100;
                document.getElementById('chromatic').max = 10;
                document.getElementById('grain').max = 100;
                document.getElementById('tracking').max = 100;
                document.getElementById('static').max = 100;
                document.getElementById('bleed').max = 100;
                document.getElementById('curvature').max = 100;
                document.getElementById('glitch').max = 100;
                
                const valueDisplays = document.querySelectorAll('.value-display');
                valueDisplays.forEach(el => {
                    el.style.cursor = 'default';
                    el.title = '';
                    el.ondblclick = null;
                });
            }
        }

        function updateUIFromVariables() {
            document.getElementById('size').value = particleSize;
            document.getElementById('gravity').value = gravity;
            document.getElementById('friction').value = friction;
            document.getElementById('interaction').value = interactionForce;
            document.getElementById('distance').value = connectionDistance;
            document.getElementById('count').value = particleCount;
            document.getElementById('mode').value = mode;
            document.getElementById('speed').value = speed;
            document.getElementById('lifetime').value = lifetime;
            document.getElementById('trail').value = trailLength;
            document.getElementById('trailOpacity').value = trailOpacity;
            document.getElementById('mouseForce').value = mouseForce;
            document.getElementById('background').value = backgroundMode;
            document.getElementById('shape').value = particleShape;
            document.getElementById('sizeVar').value = sizeVariation;
            document.getElementById('windX').value = windX;
            document.getElementById('windY').value = windY;
            document.getElementById('collisions').value = collisionsEnabled ? 'on' : 'off';
            document.getElementById('bounce').value = bounce;
            document.getElementById('emitter').value = emitterMode;
            document.getElementById('emitRate').value = emitRate;
            document.getElementById('colorMode').value = colorMode;
            document.getElementById('magnetic').value = magneticField;
            document.getElementById('vortex').value = vortexStrength;
            document.getElementById('noise').value = noiseAmount;
            document.getElementById('flocking').value = flockingEnabled ? 'on' : 'off';
            document.getElementById('sizeOverLife').value = sizeOverLife;
            document.getElementById('colorOverLife').value = colorOverLife;
            document.getElementById('blendMode').value = blendMode;
            document.getElementById('velocityViz').value = velocityViz ? 'on' : 'off';
            document.getElementById('maxParticles').value = maxParticles;
            document.getElementById('vhsMode').value = vhsMode ? 'on' : 'off';
            document.getElementById('scanlines').value = scanlinesIntensity;
            document.getElementById('chromatic').value = chromaticAberration;
            document.getElementById('grain').value = filmGrain;
            document.getElementById('tracking').value = vhsTracking;
            document.getElementById('static').value = staticNoise;
            document.getElementById('bleed').value = colorBleed;
            document.getElementById('curvature').value = crtCurvature;
            document.getElementById('glitch').value = vhsGlitch;
            
            document.getElementById('sizeValue').textContent = particleSize;
            document.getElementById('gravityValue').textContent = gravity.toFixed(2);
            document.getElementById('frictionValue').textContent = friction.toFixed(2);
            document.getElementById('interactionValue').textContent = interactionForce.toFixed(1);
            document.getElementById('distanceValue').textContent = connectionDistance;
            document.getElementById('countValue').textContent = particleCount;
            document.getElementById('modeValue').textContent = document.getElementById('mode').options[document.getElementById('mode').selectedIndex].text;
            document.getElementById('speedValue').textContent = speed.toFixed(1);
            document.getElementById('lifetimeValue').textContent = lifetime + '%';
            document.getElementById('trailValue').textContent = trailLength;
            document.getElementById('trailOpacityValue').textContent = trailOpacity.toFixed(2);
            document.getElementById('mouseForceValue').textContent = mouseForce.toFixed(1);
            document.getElementById('bgValue').textContent = document.getElementById('background').options[document.getElementById('background').selectedIndex].text;
            document.getElementById('shapeValue').textContent = document.getElementById('shape').options[document.getElementById('shape').selectedIndex].text;
            document.getElementById('sizeVarValue').textContent = sizeVariation + '%';
            document.getElementById('windXValue').textContent = windX.toFixed(1);
            document.getElementById('windYValue').textContent = windY.toFixed(1);
            document.getElementById('collisionValue').textContent = collisionsEnabled ? 'ON' : 'OFF';
            document.getElementById('bounceValue').textContent = bounce.toFixed(1);
            document.getElementById('emitterValue').textContent = document.getElementById('emitter').options[document.getElementById('emitter').selectedIndex].text.toUpperCase();
            document.getElementById('emitRateValue').textContent = emitRate;
            document.getElementById('colorModeValue').textContent = document.getElementById('colorMode').options[document.getElementById('colorMode').selectedIndex].text;
            document.getElementById('magneticValue').textContent = magneticField.toFixed(1);
            document.getElementById('vortexValue').textContent = vortexStrength.toFixed(1);
            document.getElementById('noiseValue').textContent = noiseAmount.toFixed(1);
            document.getElementById('flockingValue').textContent = flockingEnabled ? 'ON' : 'OFF';
            document.getElementById('sizeOverLifeValue').textContent = document.getElementById('sizeOverLife').options[document.getElementById('sizeOverLife').selectedIndex].text;
            document.getElementById('colorOverLifeValue').textContent = document.getElementById('colorOverLife').options[document.getElementById('colorOverLife').selectedIndex].text;
            document.getElementById('blendValue').textContent = document.getElementById('blendMode').options[document.getElementById('blendMode').selectedIndex].text;
            document.getElementById('velocityVizValue').textContent = velocityViz ? 'ON' : 'OFF';
            document.getElementById('maxParticlesValue').textContent = maxParticles === Infinity ? 'UNLIMITED' : maxParticles;
            document.getElementById('vhsModeValue').textContent = vhsMode ? 'ON' : 'OFF';
            document.getElementById('scanlinesValue').textContent = scanlinesIntensity + '%';
            document.getElementById('chromaticValue').textContent = chromaticAberration.toFixed(1);
            document.getElementById('grainValue').textContent = filmGrain + '%';
            document.getElementById('trackingValue').textContent = vhsTracking + '%';
            document.getElementById('staticValue').textContent = staticNoise + '%';
            document.getElementById('bleedValue').textContent = colorBleed + '%';
            document.getElementById('curvatureValue').textContent = crtCurvature + '%';
            document.getElementById('glitchValue').textContent = vhsGlitch + '%';
            document.getElementById('tornadoEnabled').value = tornadoEnabled ? 'on' : 'off';
            document.getElementById('tornadoStrength').value = tornadoStrength;
            document.getElementById('tornadoSpeed').value = tornadoSpeed;
            document.getElementById('tornadoSize').value = tornadoSize;
            document.getElementById('tsunamiEnabled').value = tsunamiEnabled ? 'on' : 'off';
            document.getElementById('tsunamiStrength').value = tsunamiStrength;
            document.getElementById('volcanoEnabled').value = volcanoEnabled ? 'on' : 'off';
            document.getElementById('volcanoIntensity').value = volcanoIntensity;
            document.getElementById('thunderEnabled').value = thunderEnabled ? 'on' : 'off';
            document.getElementById('thunderFreq').value = thunderFreq;
            document.getElementById('rainEnabled').value = rainEnabled ? 'on' : 'off';
            document.getElementById('rainIntensity').value = rainIntensity;
            document.getElementById('snowEnabled').value = snowEnabled ? 'on' : 'off';
            document.getElementById('snowIntensity').value = snowIntensity;
            document.getElementById('hurricaneEnabled').value = hurricaneEnabled ? 'on' : 'off';
            document.getElementById('hurricaneStrength').value = hurricaneStrength;
            document.getElementById('earthquakeEnabled').value = earthquakeEnabled ? 'on' : 'off';
            document.getElementById('earthquakeIntensity').value = earthquakeIntensity;
            
            document.getElementById('tornadoEnabledValue').textContent = tornadoEnabled ? 'ON' : 'OFF';
            document.getElementById('tornadoStrengthValue').textContent = tornadoStrength.toFixed(1);
            document.getElementById('tornadoSpeedValue').textContent = tornadoSpeed.toFixed(1);
            document.getElementById('tornadoSizeValue').textContent = tornadoSize;
            document.getElementById('tsunamiEnabledValue').textContent = tsunamiEnabled ? 'ON' : 'OFF';
            document.getElementById('tsunamiStrengthValue').textContent = tsunamiStrength.toFixed(1);
            document.getElementById('volcanoEnabledValue').textContent = volcanoEnabled ? 'ON' : 'OFF';
            document.getElementById('volcanoIntensityValue').textContent = volcanoIntensity.toFixed(1);
            document.getElementById('thunderEnabledValue').textContent = thunderEnabled ? 'ON' : 'OFF';
            document.getElementById('thunderFreqValue').textContent = thunderFreq.toFixed(1);
            document.getElementById('rainEnabledValue').textContent = rainEnabled ? 'ON' : 'OFF';
            document.getElementById('rainIntensityValue').textContent = rainIntensity.toFixed(1);
            document.getElementById('snowEnabledValue').textContent = snowEnabled ? 'ON' : 'OFF';
            document.getElementById('snowIntensityValue').textContent = snowIntensity.toFixed(1);
            document.getElementById('hurricaneEnabledValue').textContent = hurricaneEnabled ? 'ON' : 'OFF';
            document.getElementById('hurricaneStrengthValue').textContent = hurricaneStrength.toFixed(1);
            document.getElementById('earthquakeEnabledValue').textContent = earthquakeEnabled ? 'ON' : 'OFF';
            document.getElementById('earthquakeIntensityValue').textContent = earthquakeIntensity.toFixed(1);
            
            ctx.globalCompositeOperation = blendMode;
        }

        function resetSettings() {
            particleSize = 3;
            gravity = 0.1;
            friction = 0.99;
            interactionForce = 0.5;
            connectionDistance = 100;
            particleCount = 20;
            mode = 'click';
            speed = 1.0;
            lifetime = 100;
            trailLength = 5;
            trailOpacity = 0.3;
            mouseForce = 1.0;
            backgroundMode = 'dark';
            particleShape = 'circle';
            sizeVariation = 50;
            windX = 0;
            windY = 0;
            collisionsEnabled = false;
            bounce = 0.8;
            emitterMode = 'off';
            emitRate = 5;
            colorMode = 'single';
            magneticField = 0;
            vortexStrength = 0;
            noiseAmount = 0;
            flockingEnabled = false;
            sizeOverLife = 'off';
            colorOverLife = 'off';
            blendMode = 'normal';
            velocityViz = false;
            maxParticles = 10000;
            vhsMode = false;
            scanlinesIntensity = 0;
            chromaticAberration = 0;
            filmGrain = 0;
            vhsTracking = 0;
            staticNoise = 0;
            colorBleed = 0;
            crtCurvature = 0;
            vhsGlitch = 0;
            tornadoEnabled = false;
            tornadoStrength = 5.0;
            tornadoSpeed = 2.0;
            tornadoSize = 150;
            tornado = null;
            tsunamiEnabled = false;
            tsunamiStrength = 3.0;
            tsunamiWaves = [];
            volcanoEnabled = false;
            volcanoIntensity = 5.0;
            volcano = null;
            thunderEnabled = false;
            thunderFreq = 2.0;
            thunderTimer = 0;
            lightningStrikes = [];
            thunderFlash = 0;
            thunderShake = { x: 0, y: 0 };
            rainEnabled = false;
            rainIntensity = 3.0;
            rainDrops = [];
            snowEnabled = false;
            snowIntensity = 2.0;
            snowFlakes = [];
            hurricaneEnabled = false;
            hurricaneStrength = 6.0;
            hurricane = null;
            earthquakeEnabled = false;
            earthquakeIntensity = 3.0;
            earthquakeTimer = 0;
            earthquakeShake = { x: 0, y: 0 };
            
            updateUIFromVariables();
        }

        function loadPreset(name) {
            clearParticles();
            switch(name) {
                case 'fireworks':
                    particleSize = 4;
                    particleCount = 50;
                    mode = 'explosion';
                    speed = 1.5;
                    gravity = 0.15;
                    lifetime = 80;
                    trailLength = 8;
                    colorMode = 'random';
                    interactionForce = 0.3;
                    break;
                case 'galaxy':
                    particleSize = 2;
                    particleCount = 100;
                    mode = 'spiral';
                    speed = 0.8;
                    gravity = 0;
                    friction = 0.995;
                    lifetime = 150;
                    connectionDistance = 150;
                    colorMode = 'gradient';
                    interactionForce = 1.5;
                    break;
                case 'plasma':
                    particleSize = 5;
                    particleCount = 30;
                    mode = 'auto';
                    speed = 1.2;
                    gravity = 0;
                    friction = 0.97;
                    lifetime = 120;
                    connectionDistance = 200;
                    colorMode = 'rainbow';
                    interactionForce = 2.0;
                    break;
                case 'vortex':
                    particleSize = 3;
                    particleCount = 100;
                    mode = 'spiral';
                    speed = 0.8;
                    gravity = 0;
                    friction = 0.99;
                    lifetime = 200;
                    vortexStrength = 3.0;
                    colorMode = 'gradient';
                    interactionForce = 1.0;
                    break;
                case 'flocking':
                    particleSize = 2;
                    particleCount = 150;
                    mode = 'auto';
                    speed = 1.0;
                    gravity = 0;
                    friction = 0.98;
                    lifetime = 150;
                    flockingEnabled = true;
                    colorMode = 'velocity';
                    interactionForce = 0.5;
                    break;
                case 'magnetic':
                    particleSize = 4;
                    particleCount = 80;
                    mode = 'spiral';
                    speed = 0.6;
                    gravity = 0;
                    friction = 0.995;
                    lifetime = 180;
                    magneticField = 4.0;
                    colorMode = 'age';
                    interactionForce = 1.5;
                    break;
                case 'chaos':
                    particleSize = 3;
                    particleCount = 200;
                    mode = 'explosion';
                    speed = 2.0;
                    gravity = 0.2;
                    friction = 0.95;
                    lifetime = 100;
                    noiseAmount = 1.5;
                    collisionsEnabled = true;
                    colorMode = 'random';
                    interactionForce = 2.5;
                    break;
                case 'nebula':
                    particleSize = 4;
                    particleCount = 80;
                    mode = 'spiral';
                    speed = 0.5;
                    gravity = 0;
                    friction = 0.99;
                    lifetime = 200;
                    connectionDistance = 180;
                    colorMode = 'gradient';
                    interactionForce = 1.2;
                    blendMode = 'screen';
                    trailLength = 12;
                    break;
                case 'stars':
                    particleSize = 1;
                    particleCount = 300;
                    mode = 'auto';
                    speed = 0.3;
                    gravity = 0;
                    friction = 1;
                    lifetime = 300;
                    colorMode = 'single';
                    currentColor = '#ffffff';
                    trailLength = 0;
                    sizeOverLife = 'pulse';
                    break;
                case 'smoke':
                    particleSize = 6;
                    particleCount = 40;
                    mode = 'fountain';
                    speed = 0.8;
                    gravity = -0.05;
                    friction = 0.98;
                    lifetime = 150;
                    colorMode = 'single';
                    currentColor = '#666666';
                    trailLength = 15;
                    sizeOverLife = 'grow';
                    colorOverLife = 'fade';
                    windX = 0.2;
                    break;
                case 'bubbles':
                    particleSize = 5;
                    particleCount = 50;
                    mode = 'fountain';
                    speed = 0.6;
                    gravity = -0.08;
                    friction = 0.99;
                    lifetime = 180;
                    colorMode = 'gradient';
                    trailLength = 8;
                    sizeOverLife = 'grow';
                    bounce = 0.9;
                    break;
                case 'sparkles':
                    particleSize = 2;
                    particleCount = 100;
                    mode = 'explosion';
                    speed = 1.2;
                    gravity = 0.1;
                    friction = 0.97;
                    lifetime = 80;
                    colorMode = 'rainbow';
                    trailLength = 5;
                    sizeOverLife = 'shrink';
                    break;
                case 'aurora':
                    particleSize = 3;
                    particleCount = 120;
                    mode = 'spiral';
                    speed = 0.4;
                    gravity = 0;
                    friction = 0.995;
                    lifetime = 250;
                    connectionDistance = 200;
                    colorMode = 'gradient';
                    interactionForce = 0.8;
                    blendMode = 'screen';
                    trailLength = 20;
                    vortexStrength = 2.0;
                    break;
                case 'meteor':
                    particleSize = 4;
                    particleCount = 60;
                    mode = 'explosion';
                    speed = 1.8;
                    gravity = 0.12;
                    friction = 0.96;
                    lifetime = 90;
                    colorMode = 'age';
                    trailLength = 10;
                    sizeOverLife = 'shrink';
                    colorOverLife = 'heat';
                    break;
                case 'energy':
                    particleSize = 3;
                    particleCount = 100;
                    mode = 'spiral';
                    speed = 1.0;
                    gravity = 0;
                    friction = 0.99;
                    lifetime = 150;
                    connectionDistance = 120;
                    colorMode = 'velocity';
                    interactionForce = 2.0;
                    magneticField = 3.0;
                    trailLength = 8;
                    blendMode = 'screen';
                    break;
            }
            
            document.getElementById('size').value = particleSize;
            document.getElementById('count').value = particleCount;
            document.getElementById('mode').value = mode;
            document.getElementById('speed').value = speed;
            document.getElementById('gravity').value = gravity;
            document.getElementById('friction').value = friction;
            document.getElementById('lifetime').value = lifetime;
            document.getElementById('trail').value = trailLength;
            document.getElementById('distance').value = connectionDistance;
            document.getElementById('interaction').value = interactionForce;
            document.getElementById('windX').value = windX;
            document.getElementById('windY').value = windY;
            document.getElementById('colorMode').value = colorMode;
            document.getElementById('magnetic').value = magneticField;
            document.getElementById('vortex').value = vortexStrength;
            document.getElementById('noise').value = noiseAmount;
            document.getElementById('flocking').value = flockingEnabled ? 'on' : 'off';
            document.getElementById('sizeOverLife').value = sizeOverLife;
            document.getElementById('colorOverLife').value = colorOverLife;
            document.getElementById('blendMode').value = blendMode;
            document.getElementById('velocityViz').value = velocityViz ? 'on' : 'off';
            document.getElementById('maxParticles').value = maxParticles;
            document.getElementById('collisions').value = collisionsEnabled ? 'on' : 'off';
            document.getElementById('static').value = staticNoise;
            document.getElementById('glitch').value = vhsGlitch;
            
            document.getElementById('sizeValue').textContent = particleSize;
            document.getElementById('countValue').textContent = particleCount;
            document.getElementById('modeValue').textContent = document.getElementById('mode').options[document.getElementById('mode').selectedIndex].text;
            document.getElementById('speedValue').textContent = speed.toFixed(1);
            document.getElementById('gravityValue').textContent = gravity.toFixed(2);
            document.getElementById('frictionValue').textContent = friction.toFixed(2);
            document.getElementById('lifetimeValue').textContent = lifetime + '%';
            document.getElementById('trailValue').textContent = trailLength;
            document.getElementById('distanceValue').textContent = connectionDistance;
            document.getElementById('interactionValue').textContent = interactionForce.toFixed(1);
            document.getElementById('windXValue').textContent = windX.toFixed(1);
            document.getElementById('windYValue').textContent = windY.toFixed(1);
            document.getElementById('colorModeValue').textContent = document.getElementById('colorMode').options[document.getElementById('colorMode').selectedIndex].text;
            document.getElementById('magneticValue').textContent = magneticField.toFixed(1);
            document.getElementById('vortexValue').textContent = vortexStrength.toFixed(1);
            document.getElementById('noiseValue').textContent = noiseAmount.toFixed(1);
            document.getElementById('flockingValue').textContent = flockingEnabled ? 'ON' : 'OFF';
            document.getElementById('sizeOverLifeValue').textContent = document.getElementById('sizeOverLife').options[document.getElementById('sizeOverLife').selectedIndex].text;
            document.getElementById('colorOverLifeValue').textContent = document.getElementById('colorOverLife').options[document.getElementById('colorOverLife').selectedIndex].text;
            document.getElementById('blendValue').textContent = document.getElementById('blendMode').options[document.getElementById('blendMode').selectedIndex].text;
            document.getElementById('velocityVizValue').textContent = velocityViz ? 'ON' : 'OFF';
            document.getElementById('maxParticlesValue').textContent = maxParticles;
            document.getElementById('collisionValue').textContent = collisionsEnabled ? 'ON' : 'OFF';
            document.getElementById('staticValue').textContent = staticNoise + '%';
            document.getElementById('glitchValue').textContent = vhsGlitch + '%';
            
            if (currentColor) {
                document.getElementById('customColor').value = currentColor;
                document.querySelectorAll('.color-btn').forEach(b => {
                    if (b.style.background === currentColor) {
                        b.classList.add('active');
                    } else {
                        b.classList.remove('active');
                    }
                });
            }
        }

        class Particle {
            constructor(x, y, color, vx = null, vy = null) {
                this.x = x;
                this.y = y;
                this.vx = vx !== null ? vx : (Math.random() - 0.5) * 4;
                this.vy = vy !== null ? vy : (Math.random() - 0.5) * 4;
                const sizeVar = (sizeVariation / 100) * particleSize;
                this.size = particleSize + (Math.random() - 0.5) * sizeVar;
                this.color = color;
                this.maxLife = 1;
                this.life = 1;
                this.decay = (Math.random() * 0.001 + 0.0005) * (100 / lifetime);
                this.mass = this.size;
                this.history = [];
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.shape = particleShape;
                this.initialSize = this.size;
                this.initialColor = color;
                this.age = 0;
                this.maxAge = 1;
            }

            update() {
                if (physicsEnabled) {
                    if (this.isVolcano && this.volcanoGravity !== undefined) {
                        this.vy += this.volcanoGravity;
                    } else {
                        this.vy += gravity;
                    }
                    this.vx += windX;
                    this.vy += windY;
                    this.vx *= friction;
                    this.vy *= friction;
                }

                this.x += this.vx * speed;
                this.y += this.vy * speed;

                if (this.x < 0) {
                    this.x = 0;
                    this.vx *= -bounce;
                }
                if (this.x > canvas.width) {
                    this.x = canvas.width;
                    this.vx *= -bounce;
                }
                if (this.y < 0) {
                    this.y = 0;
                    this.vy *= -bounce;
                }
                if (this.y > canvas.height) {
                    this.y = canvas.height;
                    this.vy *= -bounce;
                }

                if (collisionsEnabled) {
                    this.checkCollisions();
                }

                if (interactionForce > 0) {
                    this.applyInteractions();
                }

                this.applyMouseForce();
                this.applyFieldForces();
                this.applyNoise();
                this.applyTornado();
                this.applyTsunami();
                this.applyVolcano();
                this.applyHurricane();
                this.applyEarthquake();
                this.applyThunderShake();
                
                this.age += 0.01;
                this.updateAging();

                this.rotation += this.rotationSpeed;

                if (trailLength > 0) {
                    this.history.push({ x: this.x, y: this.y, life: this.life });
                    if (this.history.length > trailLength) {
                        this.history.shift();
                    }
                }

                this.life -= this.decay;
            }

            applyInteractions() {
                const maxCheck = devMode ? particles.length : Math.min(particles.length, 50);
                for (let i = 0; i < maxCheck; i++) {
                    const other = particles[Math.floor(Math.random() * particles.length)];
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const maxDist = devMode ? 10000 : 60;
                    if (distance > 0 && distance < maxDist) {
                        const force = (maxDist - distance) / maxDist * interactionForce;
                        const angle = Math.atan2(dy, dx);
                        this.vx += Math.cos(angle) * force * 0.02;
                        this.vy += Math.sin(angle) * force * 0.02;
                    }
                }
            }

            applyMouseForce() {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const mouseMaxDist = devMode ? 10000 : 150;
                if (distance < mouseMaxDist && distance > 0) {
                    const force = (mouseMaxDist - distance) / mouseMaxDist * mouseForce;
                    const angle = Math.atan2(dy, dx);
                    
                    if (rightMouseDown) {
                        this.vx -= Math.cos(angle) * force * 3;
                        this.vy -= Math.sin(angle) * force * 3;
                    } else if (middleMouseDown) {
                        this.vx += Math.cos(angle) * force * 2;
                        this.vy += Math.sin(angle) * force * 2;
                    }
                }
            }

            checkCollisions() {
                const maxCheck = devMode ? particles.length : Math.min(particles.length, 30);
                for (let i = 0; i < maxCheck; i++) {
                    const other = particles[Math.floor(Math.random() * particles.length)];
                    if (other === this || other.life <= 0) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (this.size + other.size) * 0.8;
                    
                    if (distance < minDist && distance > 0) {
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDist - distance;
                        const moveX = Math.cos(angle) * overlap * 0.5;
                        const moveY = Math.sin(angle) * overlap * 0.5;
                        
                        this.x -= moveX;
                        this.y -= moveY;
                        other.x += moveX;
                        other.y += moveY;
                        
                        const relativeVx = this.vx - other.vx;
                        const relativeVy = this.vy - other.vy;
                        const dotProduct = relativeVx * Math.cos(angle) + relativeVy * Math.sin(angle);
                        
                        if (dotProduct > 0) {
                            const impulse = dotProduct * bounce * 0.5;
                            this.vx -= Math.cos(angle) * impulse;
                            this.vy -= Math.sin(angle) * impulse;
                            other.vx += Math.cos(angle) * impulse;
                            other.vy += Math.sin(angle) * impulse;
                        }
                    }
                }
            }

            applyFieldForces() {
                if (magneticField > 0) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const dx = centerX - this.x;
                    const dy = centerY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        const force = magneticField / (distance * 0.01 + 1);
                        const angle = Math.atan2(dy, dx);
                        this.vx += Math.cos(angle) * force * 0.01;
                        this.vy += Math.sin(angle) * force * 0.01;
                    }
                }

                if (vortexStrength > 0) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const dx = this.x - centerX;
                    const dy = this.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        const force = vortexStrength / (distance * 0.01 + 1);
                        const angle = Math.atan2(dy, dx) + Math.PI / 2;
                        this.vx += Math.cos(angle) * force * 0.01;
                        this.vy += Math.sin(angle) * force * 0.01;
                    }
                }

                if (flockingEnabled) {
                    this.applyFlocking();
                }
            }

            applyFlocking() {
                const neighbors = [];
                const maxCheck = devMode ? particles.length : Math.min(particles.length, 20);
                for (let i = 0; i < maxCheck; i++) {
                    const other = particles[Math.floor(Math.random() * particles.length)];
                    if (other === this) continue;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const flockDist = devMode ? 10000 : 80;
                    if (distance < flockDist && distance > 0) {
                        neighbors.push({ particle: other, distance });
                    }
                }

                if (neighbors.length > 0) {
                    let avgVx = 0, avgVy = 0, avgX = 0, avgY = 0;
                    neighbors.forEach(n => {
                        avgVx += n.particle.vx;
                        avgVy += n.particle.vy;
                        avgX += n.particle.x;
                        avgY += n.particle.y;
                    });
                    avgVx /= neighbors.length;
                    avgVy /= neighbors.length;
                    avgX /= neighbors.length;
                    avgY /= neighbors.length;

                    this.vx += (avgVx - this.vx) * 0.01;
                    this.vy += (avgVy - this.vy) * 0.01;

                    const dx = avgX - this.x;
                    const dy = avgY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        this.vx += (dx / distance) * 0.005;
                        this.vy += (dy / distance) * 0.005;
                    }
                }
            }

            applyNoise() {
                if (noiseAmount > 0) {
                    this.vx += (Math.random() - 0.5) * noiseAmount * 0.1;
                    this.vy += (Math.random() - 0.5) * noiseAmount * 0.1;
                }
            }

            applyTornado() {
                if (!tornado || !tornado.active) return;
                
                const dx = tornado.x - this.x;
                const dy = tornado.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDist = tornadoSize;
                
                if (distance < maxDist && distance > 0) {
                    const pullStrength = (1 - distance / maxDist) * tornadoStrength;
                    const angle = Math.atan2(dy, dx);
                    
                    const pullX = Math.cos(angle) * pullStrength * 0.05;
                    const pullY = Math.sin(angle) * pullStrength * 0.05;
                    
                    this.vx += pullX;
                    this.vy += pullY;
                    
                    const spinAngle = angle + Math.PI / 2;
                    const spinForce = pullStrength * 0.3;
                    this.vx += Math.cos(spinAngle) * spinForce * 0.1;
                    this.vy += Math.sin(spinAngle) * spinForce * 0.1;
                }
            }

            applyTsunami() {
                if (!tsunamiEnabled || tsunamiWaves.length === 0) return;
                
                for (const wave of tsunamiWaves) {
                    const waveY = wave.y;
                    const distance = Math.abs(this.y - waveY);
                    const waveWidth = 100;
                    
                    if (distance < waveWidth) {
                        const force = (1 - distance / waveWidth) * tsunamiStrength;
                        const direction = wave.direction;
                        this.vx += direction * force * 0.1;
                        this.vy += (Math.random() - 0.5) * force * 0.05;
                    }
                }
            }

            applyVolcano() {
                if (!volcano || !volcano.active) return;
                
                const dx = volcano.x - this.x;
                const dy = volcano.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDist = 200;
                
                if (distance < maxDist && distance > 0 && this.y > volcano.y) {
                    const force = (1 - distance / maxDist) * volcanoIntensity;
                    const angle = Math.atan2(dy, dx);
                    
                    this.vx -= Math.cos(angle) * force * 0.08;
                    this.vy -= Math.sin(angle) * force * 0.15;
                }
            }

            applyHurricane() {
                if (!hurricane || !hurricane.active) return;
                
                const dx = this.x - hurricane.x;
                const dy = this.y - hurricane.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDist = 400;
                
                if (distance < maxDist && distance > 0) {
                    const force = (1 - distance / maxDist) * hurricaneStrength;
                    const angle = Math.atan2(dy, dx) + Math.PI / 2;
                    
                    this.vx += Math.cos(angle) * force * 0.05;
                    this.vy += Math.sin(angle) * force * 0.05;
                    
                    const pullAngle = Math.atan2(dy, dx);
                    this.vx += Math.cos(pullAngle) * force * 0.02;
                    this.vy += Math.sin(pullAngle) * force * 0.02;
                }
            }

            applyEarthquake() {
                if (!earthquakeEnabled) return;
                
                this.x += earthquakeShake.x;
                this.y += earthquakeShake.y;
            }

            applyThunderShake() {
                if (!thunderEnabled) return;
                
                this.x += thunderShake.x;
                this.y += thunderShake.y;
            }

            updateAging() {
                const lifeRatio = this.life / this.maxLife;
                
                if (sizeOverLife !== 'off') {
                    if (sizeOverLife === 'shrink') {
                        this.size = this.initialSize * lifeRatio;
                    } else if (sizeOverLife === 'grow') {
                        this.size = this.initialSize * (2 - lifeRatio);
                    } else if (sizeOverLife === 'pulse') {
                        this.size = this.initialSize * (1 + Math.sin(this.age * 10) * 0.3);
                    }
                }

                if (colorOverLife !== 'off') {
                    if (colorOverLife === 'fade') {
                        const alpha = lifeRatio;
                        const rgb = this.hexToRgb(this.initialColor);
                        this.color = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
                    } else if (colorOverLife === 'shift') {
                        const hue = (this.age * 50) % 360;
                        this.color = `hsl(${hue}, 70%, 60%)`;
                    } else if (colorOverLife === 'heat') {
                        const heat = lifeRatio;
                        const r = Math.min(255, heat * 255);
                        const g = Math.min(255, (1 - Math.abs(heat - 0.5) * 2) * 255);
                        const b = Math.max(0, (1 - heat) * 255);
                        this.color = `rgb(${r}, ${g}, ${b})`;
                    }
                }
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 74, g: 158, b: 255 };
            }

            draw() {
                if (trailLength > 0 && this.history.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.size * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    for (let i = 1; i < this.history.length; i++) {
                        const alpha = (this.history[i].life / this.maxLife) * trailOpacity;
                        ctx.globalAlpha = alpha;
                        ctx.lineTo(this.history[i].x, this.history[i].y);
                    }
                    ctx.stroke();
                }

                if (velocityViz) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.vx * 5, this.y + this.vy * 5);
                    ctx.stroke();
                }

                ctx.globalAlpha = this.life;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                
                switch(this.shape) {
                    case 'square':
                        ctx.rect(-this.size, -this.size, this.size * 2, this.size * 2);
                        break;
                    case 'triangle':
                        ctx.moveTo(0, -this.size);
                        ctx.lineTo(-this.size, this.size);
                        ctx.lineTo(this.size, this.size);
                        ctx.closePath();
                        break;
                    case 'star':
                        for (let i = 0; i < 5; i++) {
                            const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                            const x = Math.cos(angle) * this.size;
                            const y = Math.sin(angle) * this.size;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                            
                            const innerAngle = angle + Math.PI / 5;
                            const innerX = Math.cos(innerAngle) * this.size * 0.5;
                            const innerY = Math.sin(innerAngle) * this.size * 0.5;
                            ctx.lineTo(innerX, innerY);
                        }
                        ctx.closePath();
                        break;
                    case 'line':
                        ctx.moveTo(-this.size, 0);
                        ctx.lineTo(this.size, 0);
                        ctx.lineWidth = this.size * 0.3;
                        ctx.stroke();
                        ctx.restore();
                        return;
                    default:
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                }
                
                ctx.fill();
                
                ctx.globalAlpha = this.life * 0.4;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = this.size * 2;
                if (this.shape !== 'line') {
                    ctx.beginPath();
                    if (this.shape === 'circle') {
                        ctx.arc(0, 0, this.size * 0.6, 0, Math.PI * 2);
                    } else {
                        ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
        }

        function getParticleColor() {
            switch(colorMode) {
                case 'random':
                    return colors[Math.floor(Math.random() * colors.length)];
                case 'gradient':
                    const hue = (Date.now() * 0.001 + particles.length * 0.01) % 360;
                    return `hsl(${hue}, 70%, 60%)`;
                case 'rainbow':
                    const index = particles.length % colors.length;
                    return colors[index];
                case 'age':
                    const ageHue = (particles.length * 2) % 360;
                    return `hsl(${ageHue}, 70%, 60%)`;
                case 'velocity':
                    const vel = Math.sqrt(particles[particles.length - 1]?.vx ** 2 + particles[particles.length - 1]?.vy ** 2) || 0;
                    const velHue = (vel * 20) % 360;
                    return `hsl(${velHue}, 70%, 60%)`;
                default:
                    return currentColor;
            }
        }

        function spawnParticles(x, y, count, modeType) {
            for (let i = 0; i < count; i++) {
                let vx, vy;
                
                if (modeType === 'explosion') {
                    const angle = (Math.PI * 2 * i) / count;
                    const speed = Math.random() * 10 + 5;
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                } else if (modeType === 'fountain') {
                    vx = (Math.random() - 0.5) * 3;
                    vy = -Math.random() * 10 - 5;
                } else if (modeType === 'spiral') {
                    const angle = (Math.PI * 2 * i) / count;
                    const radius = i * 0.5;
                    vx = Math.cos(angle) * radius;
                    vy = Math.sin(angle) * radius;
                } else if (modeType === 'rain') {
                    vx = (Math.random() - 0.5) * 2;
                    vy = Math.random() * 5 + 3;
                } else {
                    vx = (Math.random() - 0.5) * 5;
                    vy = (Math.random() - 0.5) * 5;
                }
                
                const color = getParticleColor();
                particles.push(new Particle(x, y, color, vx, vy));
            }
        }

        function drawConnections() {
            if (!connectionsEnabled || particles.length === 0) return;
            
            const maxConnections = devMode ? particles.length : Math.min(particles.length, 100);
            const checked = new Set();
            
            for (let i = 0; i < maxConnections; i++) {
                const p1 = particles[i];
                const maxJ = devMode ? particles.length : Math.min(particles.length, i + 20);
                for (let j = i + 1; j < maxJ; j++) {
                    const p2 = particles[j];
                    const key = `${Math.min(i, j)}-${Math.max(i, j)}`;
                    if (checked.has(key)) continue;
                    checked.add(key);
                    
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < connectionDistance) {
                        const opacity = (1 - distance / connectionDistance) * 0.2 * Math.min(p1.life, p2.life);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }
        }

        function getBackgroundColor() {
            switch(backgroundMode) {
                case 'black': return 'rgba(0, 0, 0, 0.2)';
                case 'gray': return 'rgba(30, 30, 30, 0.15)';
                default: return 'rgba(10, 10, 10, 0.15)';
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                if (mode === 'click' || mode === 'explosion' || mode === 'fountain' || mode === 'spiral' || mode === 'rain') {
                    spawnParticles(mouseX, mouseY, particleCount, mode);
                }
            } else if (e.button === 2) {
                rightMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            } else if (e.button === 1) {
                middleMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (mouseDown && mode === 'click') {
                if (devMode || particles.length < maxParticles) {
                    spawnParticles(mouseX, mouseY, 1, 'click');
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) mouseDown = false;
            if (e.button === 2) rightMouseDown = false;
            if (e.button === 1) middleMouseDown = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        function clearParticles() {
            particles = [];
            attractors = [];
            repellers = [];
        }

        function saveConfig() {
            const config = {
                particleSize, gravity, friction, interactionForce, connectionDistance,
                particleCount, mode, speed, lifetime, trailLength, trailOpacity,
                mouseForce, backgroundMode, particleShape, sizeVariation, windX, windY,
                collisionsEnabled, bounce, emitterMode, emitRate, colorMode, currentColor,
                magneticField, vortexStrength, noiseAmount, flockingEnabled, sizeOverLife,
                colorOverLife, blendMode, velocityViz, maxParticles, vhsMode, scanlinesIntensity,
                chromaticAberration, filmGrain, vhsTracking, staticNoise, colorBleed, crtCurvature, vhsGlitch,
                tornadoEnabled, tornadoStrength, tornadoSpeed, tornadoSize,
                tsunamiEnabled, tsunamiStrength,
                volcanoEnabled, volcanoIntensity,
                thunderEnabled, thunderFreq,
                rainEnabled, rainIntensity,
                snowEnabled, snowIntensity,
                hurricaneEnabled, hurricaneStrength,
                earthquakeEnabled, earthquakeIntensity
            };
            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'particle-sandbox-config.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const config = JSON.parse(event.target.result);
                            
                            if (config.particleSize !== undefined) particleSize = config.particleSize;
                            if (config.gravity !== undefined) gravity = config.gravity;
                            if (config.friction !== undefined) friction = config.friction;
                            if (config.interactionForce !== undefined) interactionForce = config.interactionForce;
                            if (config.connectionDistance !== undefined) connectionDistance = config.connectionDistance;
                            if (config.particleCount !== undefined) particleCount = config.particleCount;
                            if (config.mode !== undefined) mode = config.mode;
                            if (config.speed !== undefined) speed = config.speed;
                            if (config.lifetime !== undefined) lifetime = config.lifetime;
                            if (config.trailLength !== undefined) trailLength = config.trailLength;
                            if (config.trailOpacity !== undefined) trailOpacity = config.trailOpacity;
                            if (config.mouseForce !== undefined) mouseForce = config.mouseForce;
                            if (config.backgroundMode !== undefined) backgroundMode = config.backgroundMode;
                            if (config.particleShape !== undefined) particleShape = config.particleShape;
                            if (config.sizeVariation !== undefined) sizeVariation = config.sizeVariation;
                            if (config.windX !== undefined) windX = config.windX;
                            if (config.windY !== undefined) windY = config.windY;
                            if (config.collisionsEnabled !== undefined) collisionsEnabled = config.collisionsEnabled;
                            if (config.bounce !== undefined) bounce = config.bounce;
                            if (config.emitterMode !== undefined) emitterMode = config.emitterMode;
                            if (config.emitRate !== undefined) emitRate = config.emitRate;
                            if (config.colorMode !== undefined) colorMode = config.colorMode;
                            if (config.currentColor !== undefined) currentColor = config.currentColor;
                            if (config.magneticField !== undefined) magneticField = config.magneticField;
                            if (config.vortexStrength !== undefined) vortexStrength = config.vortexStrength;
                            if (config.noiseAmount !== undefined) noiseAmount = config.noiseAmount;
                            if (config.flockingEnabled !== undefined) flockingEnabled = config.flockingEnabled;
                            if (config.sizeOverLife !== undefined) sizeOverLife = config.sizeOverLife;
                            if (config.colorOverLife !== undefined) colorOverLife = config.colorOverLife;
                            if (config.blendMode !== undefined) blendMode = config.blendMode;
                            if (config.velocityViz !== undefined) velocityViz = config.velocityViz;
                            if (config.maxParticles !== undefined) maxParticles = config.maxParticles;
                            if (config.vhsMode !== undefined) vhsMode = config.vhsMode;
                            if (config.scanlinesIntensity !== undefined) scanlinesIntensity = config.scanlinesIntensity;
                            if (config.chromaticAberration !== undefined) chromaticAberration = config.chromaticAberration;
                            if (config.filmGrain !== undefined) filmGrain = config.filmGrain;
                            if (config.vhsTracking !== undefined) vhsTracking = config.vhsTracking;
                            if (config.staticNoise !== undefined) staticNoise = config.staticNoise;
                            if (config.colorBleed !== undefined) colorBleed = config.colorBleed;
                            if (config.crtCurvature !== undefined) crtCurvature = config.crtCurvature;
                            if (config.vhsGlitch !== undefined) vhsGlitch = config.vhsGlitch;
                            if (config.tornadoEnabled !== undefined) tornadoEnabled = config.tornadoEnabled;
                            if (config.tornadoStrength !== undefined) tornadoStrength = config.tornadoStrength;
                            if (config.tornadoSpeed !== undefined) tornadoSpeed = config.tornadoSpeed;
                            if (config.tornadoSize !== undefined) tornadoSize = config.tornadoSize;
                            if (config.tsunamiEnabled !== undefined) tsunamiEnabled = config.tsunamiEnabled;
                            if (config.tsunamiStrength !== undefined) tsunamiStrength = config.tsunamiStrength;
                            if (config.volcanoEnabled !== undefined) volcanoEnabled = config.volcanoEnabled;
                            if (config.volcanoIntensity !== undefined) volcanoIntensity = config.volcanoIntensity;
                            if (config.thunderEnabled !== undefined) thunderEnabled = config.thunderEnabled;
                            if (config.thunderFreq !== undefined) thunderFreq = config.thunderFreq;
                            if (config.rainEnabled !== undefined) rainEnabled = config.rainEnabled;
                            if (config.rainIntensity !== undefined) rainIntensity = config.rainIntensity;
                            if (config.snowEnabled !== undefined) snowEnabled = config.snowEnabled;
                            if (config.snowIntensity !== undefined) snowIntensity = config.snowIntensity;
                            if (config.hurricaneEnabled !== undefined) hurricaneEnabled = config.hurricaneEnabled;
                            if (config.hurricaneStrength !== undefined) hurricaneStrength = config.hurricaneStrength;
                            if (config.earthquakeEnabled !== undefined) earthquakeEnabled = config.earthquakeEnabled;
                            if (config.earthquakeIntensity !== undefined) earthquakeIntensity = config.earthquakeIntensity;
                            
                            if (tornadoEnabled && !tornado) {
                                tornado = { x: canvas.width / 2, y: canvas.height + 50, rotation: 0, path: [], active: true };
                            } else if (!tornadoEnabled) {
                                tornado = null;
                            }
                            if (volcanoEnabled && !volcano) {
                                volcano = { x: canvas.width / 2, y: canvas.height - 20, eruptionTimer: 0, active: true };
                            } else if (!volcanoEnabled) {
                                volcano = null;
                            }
                            if (hurricaneEnabled && !hurricane) {
                                hurricane = { x: canvas.width / 2, y: canvas.height / 2, rotation: 0, active: true };
                            } else if (!hurricaneEnabled) {
                                hurricane = null;
                            }
                            
                            updateUIFromVariables();
                            alert('Configuration loaded!');
                        } catch (error) {
                            alert('Error loading configuration: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function exportImage() {
            const link = document.createElement('a');
            link.download = 'particle-sandbox-' + Date.now() + '.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportGIF() {
            if (!gifRecording) {
                gifRecording = true;
                gifFrames = [];
                gifFrameCount = 0;
                alert('Recording GIF... Click Export GIF again to stop and download.');
            } else {
                gifRecording = false;
                alert('GIF recording stopped. Processing frames...');
                setTimeout(() => {
                    alert('GIF export feature requires a library. Use Export Image for screenshots.');
                }, 100);
            }
        }

        function applyVHSEffects() {
            if (!vhsMode && scanlinesIntensity === 0 && chromaticAberration === 0 && 
                filmGrain === 0 && vhsTracking === 0 && staticNoise === 0 && 
                colorBleed === 0 && crtCurvature === 0 && vhsGlitch === 0) {
                return;
            }

            vhsCanvas.width = canvas.width;
            vhsCanvas.height = canvas.height;
            vhsCtx.drawImage(canvas, 0, 0);

            const imageData = vhsCtx.getImageData(0, 0, vhsCanvas.width, vhsCanvas.height);
            const data = imageData.data;
            const width = vhsCanvas.width;
            const height = vhsCanvas.height;

            glitchTimer++;

            if (chromaticAberration > 0) {
                const offset = chromaticAberration * 2;
                const rData = new Uint8ClampedArray(data);
                const gData = new Uint8ClampedArray(data);
                const bData = new Uint8ClampedArray(data);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const rIdx = (y * width + Math.max(0, Math.min(width - 1, x + offset))) * 4;
                        const bIdx = (y * width + Math.max(0, Math.min(width - 1, x - offset))) * 4;

                        rData[idx] = data[rIdx];
                        gData[idx + 1] = data[idx + 1];
                        bData[idx + 2] = data[bIdx + 2];
                    }
                }

                for (let i = 0; i < data.length; i += 4) {
                    data[i] = rData[i];
                    data[i + 1] = gData[i + 1];
                    data[i + 2] = bData[i + 2];
                }
            }

            if (colorBleed > 0) {
                const bleedAmount = colorBleed * 0.01;
                for (let y = 0; y < height; y++) {
                    for (let x = 1; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const prevIdx = (y * width + (x - 1)) * 4;
                        data[idx] = data[idx] * (1 - bleedAmount) + data[prevIdx] * bleedAmount;
                    }
                }
            }

            if (filmGrain > 0) {
                const grainAmount = filmGrain * 2.55;
                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * grainAmount;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                }
            }

            if (staticNoise > 0) {
                const staticAmount = staticNoise * 0.01;
                for (let i = 0; i < data.length; i += 4) {
                    if (Math.random() < staticAmount) {
                        const val = Math.random() * 255;
                        data[i] = val;
                        data[i + 1] = val;
                        data[i + 2] = val;
                    }
                }
            }

            if (vhsGlitch > 0 && Math.random() < vhsGlitch * 0.01) {
                const glitchHeight = Math.random() * 20 + 5;
                const glitchY = Math.random() * (height - glitchHeight);
                const glitchOffset = (Math.random() - 0.5) * 30;
                for (let y = glitchY; y < Math.min(height, glitchY + glitchHeight); y++) {
                    for (let x = 0; x < width; x++) {
                        const srcX = Math.max(0, Math.min(width - 1, x + glitchOffset));
                        const idx = (y * width + x) * 4;
                        const srcIdx = (y * width + srcX) * 4;
                        data[idx] = data[srcIdx];
                        data[idx + 1] = data[srcIdx + 1];
                        data[idx + 2] = data[srcIdx + 2];
                    }
                }
            }

            vhsCtx.putImageData(imageData, 0, 0);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(vhsCanvas, 0, 0);

            if (scanlinesIntensity > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${scanlinesIntensity * 0.01})`;
                for (let y = 0; y < height; y += 2) {
                    ctx.fillRect(0, y, width, 1);
                }
            }

            if (vhsTracking > 0) {
                const trackingLines = Math.floor(vhsTracking * 0.1);
                for (let i = 0; i < trackingLines; i++) {
                    const y = (glitchTimer * 0.5 + i * 50) % height;
                    ctx.strokeStyle = `rgba(255, 0, 0, ${vhsTracking * 0.01})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }

            if (crtCurvature > 0) {
                const curvatureAmount = crtCurvature * 0.01;
                const centerX = width / 2;
                const centerY = height / 2;
                
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCtx.drawImage(vhsCanvas, 0, 0);
                
                ctx.clearRect(0, 0, width, height);
                
                const segments = Math.max(8, Math.min(32, Math.floor(crtCurvature / 3)));
                const segmentWidth = width / segments;
                const segmentHeight = height / segments;
                
                for (let sy = 0; sy < segments; sy++) {
                    for (let sx = 0; sx < segments; sx++) {
                        const x = sx * segmentWidth;
                        const y = sy * segmentHeight;
                        const dx = (x + segmentWidth / 2) - centerX;
                        const dy = (y + segmentHeight / 2) - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
                        const normalizedDist = dist / maxDist;
                        
                        const curve = Math.pow(normalizedDist, 2) * curvatureAmount * 0.1;
                        const offsetX = dx * curve;
                        const offsetY = dy * curve;
                        
                        const srcX = Math.max(0, Math.min(width - segmentWidth, x + offsetX));
                        const srcY = Math.max(0, Math.min(height - segmentHeight, y + offsetY));
                        
                        ctx.drawImage(
                            tempCanvas,
                            srcX, srcY, segmentWidth, segmentHeight,
                            x, y, segmentWidth, segmentHeight
                        );
                    }
                }
                
                ctx.restore();
            }
        }

        function animate(currentTime) {
            if (!applicationStarted) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            fpsTimer += deltaTime;
            frameCount++;
            if (fpsTimer >= 1000) {
                fps = (frameCount * 1000) / fpsTimer;
                frameCount = 0;
                fpsTimer = 0;
                updateStats();
            }

            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = getBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (blendMode !== 'normal') {
                ctx.globalCompositeOperation = blendMode;
            }

            if (mode === 'auto') {
                autoSpawnTimer++;
                if (autoSpawnTimer > 30) {
                    autoSpawnTimer = 0;
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    spawnParticles(x, y, particleCount, 'click');
                }
            }

            if (mode === 'rain') {
                autoSpawnTimer++;
                if (autoSpawnTimer > 5) {
                    autoSpawnTimer = 0;
                    const x = Math.random() * canvas.width;
                    spawnParticles(x, -10, 1, 'rain');
                }
            }

            if (emitterMode !== 'off') {
                emitTimer++;
                if (emitTimer >= (60 / emitRate)) {
                    emitTimer = 0;
                    let x, y;
                    switch(emitterMode) {
                        case 'mouse':
                            x = mouseX;
                            y = mouseY;
                            break;
                        case 'center':
                            x = canvas.width / 2;
                            y = canvas.height / 2;
                            break;
                        case 'random':
                            x = Math.random() * canvas.width;
                            y = Math.random() * canvas.height;
                            break;
                    }
            if (devMode || particles.length < maxParticles) {
                    spawnParticles(x, y, 1, 'click');
                }
                }
            }

            particles = particles.filter(p => p.life > 0);
            
            if (!devMode && particles.length > maxParticles) {
                particles = particles.slice(-maxParticles);
            }

            particles.forEach(particle => {
                particle.update();
            });

            if (connectionsEnabled) {
                drawConnections();
            }

            particles.forEach(particle => {
                particle.draw();
            });

            if (tornado && tornado.active) {
                updateTornado();
                drawTornado();
            }

            if (tsunamiEnabled) {
                updateTsunami();
                drawTsunami();
            }

            if (volcano && volcano.active) {
                updateVolcano();
                drawVolcano();
            }

            if (thunderEnabled) {
                updateThunder();
                drawThunder();
            }

            if (rainEnabled) {
                updateRain();
                drawRain();
            }

            if (snowEnabled) {
                updateSnow();
                drawSnow();
            }

            if (hurricane && hurricane.active) {
                updateHurricane();
                drawHurricane();
            }

            if (earthquakeEnabled) {
                updateEarthquake();
            }

            ctx.globalAlpha = 1;
            applyVHSEffects();
            requestAnimationFrame(animate);
        }

        function updateTornado() {
            if (!tornado) return;
            
            tornado.rotation += 0.1;
            
            if (tornado.y > -100) {
                tornado.y -= tornadoSpeed;
                
                const pathNoise = Math.sin(tornado.rotation * 0.1) * 2;
                tornado.x += pathNoise;
                
                tornado.path.push({ x: tornado.x, y: tornado.y });
                if (tornado.path.length > 50) {
                    tornado.path.shift();
                }
            } else {
                tornado.x = canvas.width / 2 + (Math.random() - 0.5) * 200;
                tornado.y = canvas.height + 50;
                tornado.path = [];
            }
        }

        function drawTornado() {
            if (!tornado) return;
            
            ctx.save();
            
            const centerX = tornado.x;
            const centerY = tornado.y;
            const radius = tornadoSize;
            
            for (let layer = 0; layer < 3; layer++) {
                const layerRadius = radius * (0.3 + layer * 0.25);
                const layerAlpha = 0.5 - layer * 0.1;
                
                const gradient = ctx.createRadialGradient(centerX, centerY, layerRadius * 0.2, centerX, centerY, layerRadius);
                if (layer === 0) {
                    gradient.addColorStop(0, `rgba(80, 60, 50, ${layerAlpha})`);
                    gradient.addColorStop(0.3, `rgba(100, 80, 70, ${layerAlpha * 0.8})`);
                    gradient.addColorStop(0.6, `rgba(120, 100, 90, ${layerAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(60, 50, 40, 0)');
                } else if (layer === 1) {
                    gradient.addColorStop(0, `rgba(90, 70, 60, ${layerAlpha})`);
                    gradient.addColorStop(0.4, `rgba(110, 90, 80, ${layerAlpha * 0.7})`);
                    gradient.addColorStop(0.8, `rgba(130, 110, 100, ${layerAlpha * 0.4})`);
                    gradient.addColorStop(1, 'rgba(70, 60, 50, 0)');
                } else {
                    gradient.addColorStop(0, `rgba(100, 80, 70, ${layerAlpha})`);
                    gradient.addColorStop(0.5, `rgba(120, 100, 90, ${layerAlpha * 0.6})`);
                    gradient.addColorStop(1, 'rgba(80, 70, 60, 0)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, layerRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            for (let i = 0; i < 12; i++) {
                const baseAngle = (tornado.rotation * 2 + (i * Math.PI / 6)) % (Math.PI * 2);
                const spiralOffset = i * 0.3;
                const startRadius = radius * 0.15;
                const endRadius = radius * 0.95;
                
                ctx.strokeStyle = `rgba(120, 100, 90, ${0.5 - i * 0.03})`;
                ctx.lineWidth = 2.5;
                ctx.shadowBlur = 3;
                ctx.shadowColor = 'rgba(100, 80, 70, 0.5)';
                
                ctx.beginPath();
                for (let r = startRadius; r < endRadius; r += 2) {
                    const angle = baseAngle + (r / radius) * Math.PI * 2 + spiralOffset;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    if (r === startRadius) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            const innerGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.1, centerX, centerY, radius * 0.3);
            innerGradient.addColorStop(0, 'rgba(60, 50, 40, 0.9)');
            innerGradient.addColorStop(0.5, 'rgba(80, 70, 60, 0.6)');
            innerGradient.addColorStop(1, 'rgba(100, 90, 80, 0)');
            
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function updateTsunami() {
            if (!tsunamiEnabled) return;
            
            if (Math.random() < 0.01) {
                tsunamiWaves.push({
                    y: canvas.height - 50,
                    direction: Math.random() < 0.5 ? 1 : -1,
                    speed: tsunamiSpeed + Math.random() * tsunamiSpeed,
                    width: tsunamiSize + Math.random() * (tsunamiSize * 0.5)
                });
            }
            
            for (let i = tsunamiWaves.length - 1; i >= 0; i--) {
                const wave = tsunamiWaves[i];
                wave.y -= wave.speed;
                
                if (wave.y < -100) {
                    tsunamiWaves.splice(i, 1);
                }
            }
        }

        function drawTsunami() {
            ctx.save();
            ctx.globalAlpha = 0.7;
            
            for (const wave of tsunamiWaves) {
                const gradient = ctx.createLinearGradient(0, wave.y, 0, wave.y + wave.width);
                gradient.addColorStop(0, 'rgba(0, 100, 200, 0.6)');
                gradient.addColorStop(0.5, 'rgba(0, 150, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 100, 200, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, wave.y, canvas.width, wave.width);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, wave.y);
                for (let x = 0; x < canvas.width; x += 10) {
                    const y = wave.y + Math.sin(x * 0.05 + Date.now() * 0.01) * 5;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function updateVolcano() {
            if (!volcano || !volcano.active) return;
            
            volcano.eruptionTimer++;
            
            if (volcano.eruptionTimer > 60 / (volcanoIntensity * volcanoSpeed)) {
                volcano.eruptionTimer = 0;
                
                const baseWidth = volcanoSize * 0.4;
                const height = volcanoSize * 0.3;
                const topY = volcano.y - height;
                
                const particleCount = Math.floor(volcanoIntensity * 2);
                for (let i = 0; i < particleCount; i++) {
                    if (devMode || particles.length < maxParticles) {
                        const angle = (-Math.PI / 2) + (Math.random() - 0.5) * 0.6;
                        const speed = volcanoSpeed * (4 + Math.random() * 4);
                        const colors = ['#ff4500', '#ff6347', '#ff8c00', '#ffa500', '#ff6600', '#ff3300', '#ff0000', '#ff5500'];
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const particle = new Particle(
                            volcano.x + (Math.random() - 0.5) * (volcanoSize * 0.1),
                            topY,
                            color,
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed
                        );
                        particle.isVolcano = true;
                        particle.volcanoGravity = -0.05;
                        particles.push(particle);
                    }
                }
            }
        }

        function drawVolcano() {
            if (!volcano) return;
            
            ctx.save();
            
            const baseWidth = volcanoSize * 0.4;
            const height = volcanoSize * 0.3;
            const topY = volcano.y - height;
            
            const baseGradient = ctx.createLinearGradient(volcano.x - baseWidth / 2, volcano.y, volcano.x, topY);
            baseGradient.addColorStop(0, 'rgba(80, 50, 40, 0.9)');
            baseGradient.addColorStop(0.5, 'rgba(60, 40, 30, 0.9)');
            baseGradient.addColorStop(1, 'rgba(50, 30, 20, 0.9)');
            
            ctx.fillStyle = baseGradient;
            ctx.beginPath();
            ctx.moveTo(volcano.x - baseWidth / 2, volcano.y);
            ctx.lineTo(volcano.x, topY);
            ctx.lineTo(volcano.x + baseWidth / 2, volcano.y);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(40, 25, 15, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * baseWidth * 0.3;
                const offsetY = Math.random() * height * 0.5;
                const rockY = volcano.y - offsetY;
                const rockX = volcano.x + offsetX;
                const rockSize = 3 + Math.random() * 4;
                
                ctx.fillStyle = `rgba(${50 + Math.random() * 20}, ${30 + Math.random() * 15}, ${20 + Math.random() * 10}, 0.7)`;
                ctx.beginPath();
                ctx.arc(rockX, rockY, rockSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const craterRadius = volcanoSize * 0.08;
            const glowRadius = volcanoSize * 0.12;
            
            if (volcano.eruptionTimer < 15) {
                const glowGradient = ctx.createRadialGradient(volcano.x, topY, craterRadius * 0.3, volcano.x, topY, glowRadius);
                glowGradient.addColorStop(0, `rgba(255, ${150 + volcano.eruptionTimer * 5}, 0, ${0.9 - volcano.eruptionTimer * 0.05})`);
                glowGradient.addColorStop(0.5, `rgba(255, ${100 + volcano.eruptionTimer * 5}, 0, ${0.6 - volcano.eruptionTimer * 0.04})`);
                glowGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(volcano.x, topY, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, ${100 + volcano.eruptionTimer * 8}, 0, ${0.95 - volcano.eruptionTimer * 0.06})`;
                ctx.beginPath();
                ctx.arc(volcano.x, topY, craterRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 200, 100, ${0.8 - volcano.eruptionTimer * 0.05})`;
                ctx.beginPath();
                ctx.arc(volcano.x, topY, craterRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function updateThunder() {
            if (!thunderEnabled) return;
            
            thunderTimer++;
            const interval = (60 / thunderFreq) * 60;
            
            if (thunderTimer > interval) {
                thunderTimer = 0;
                
                const strike = {
                    x: Math.random() * canvas.width,
                    y: 0,
                    endY: Math.random() * canvas.height * 0.7 + canvas.height * 0.1,
                    branches: [],
                    life: 20,
                    intensity: (thunderStrength / 10) * (0.8 + Math.random() * 0.2)
                };
                
                for (let i = 0; i < 3; i++) {
                    strike.branches.push({
                        x: strike.x + (Math.random() - 0.5) * thunderSize,
                        y: strike.endY * (0.3 + Math.random() * 0.4),
                        endX: strike.x + (Math.random() - 0.5) * (thunderSize * 1.5),
                        endY: strike.endY + (Math.random() - 0.5) * (thunderSize * 0.5)
                    });
                }
                
                lightningStrikes.push(strike);
                
                thunderFlash = 1.0;
                thunderShake.x = (Math.random() - 0.5) * thunderStrength * 3;
                thunderShake.y = (Math.random() - 0.5) * thunderStrength * 3;
                
                for (let i = 0; i < Math.floor(thunderStrength * 4); i++) {
                    if (devMode || particles.length < maxParticles) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = thunderStrength * (1 + Math.random() * 2);
                        const particle = new Particle(
                            strike.x + (Math.random() - 0.5) * (thunderSize * 0.3),
                            strike.endY + (Math.random() - 0.5) * (thunderSize * 0.3),
                            '#ffffaa',
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed
                        );
                        particle.life = 30;
                        particles.push(particle);
                    }
                }
            }
            
            for (let i = lightningStrikes.length - 1; i >= 0; i--) {
                lightningStrikes[i].life--;
                if (lightningStrikes[i].life <= 0) {
                    lightningStrikes.splice(i, 1);
                }
            }
            
            thunderFlash *= 0.85;
            thunderShake.x *= 0.85;
            thunderShake.y *= 0.85;
        }

        function drawThunder() {
            ctx.save();
            
            for (const strike of lightningStrikes) {
                ctx.strokeStyle = `rgba(255, 255, 200, ${strike.intensity * (strike.life / 20)})`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 255, 200, 0.8)';
                
                ctx.beginPath();
                ctx.moveTo(strike.x, strike.y);
                
                let currentY = strike.y;
                let currentX = strike.x;
                const segments = 10;
                const stepY = (strike.endY - strike.y) / segments;
                
                for (let i = 0; i < segments; i++) {
                    currentY += stepY;
                    currentX += (Math.random() - 0.5) * 15;
                    ctx.lineTo(currentX, currentY);
                }
                
                ctx.stroke();
                
                for (const branch of strike.branches) {
                    ctx.beginPath();
                    ctx.moveTo(branch.x, branch.y);
                    ctx.lineTo(branch.endX, branch.endY);
                    ctx.stroke();
                }
            }
            
            if (thunderFlash > 0) {
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = `rgba(255, 255, 255, ${thunderFlash * 0.4})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'source-over';
            }
            
            ctx.restore();
        }

        function updateRain() {
            if (!rainEnabled) return;
            
            const spawnRate = Math.floor(rainIntensity * 2);
            
            for (let i = 0; i < spawnRate; i++) {
                if (Math.random() < 0.3) {
                    rainDrops.push({
                        x: Math.random() * canvas.width,
                        y: -10,
                        speed: rainSpeed + Math.random() * rainSpeed,
                        length: rainSize + Math.random() * (rainSize * 0.5)
                    });
                }
            }
            
            for (let i = rainDrops.length - 1; i >= 0; i--) {
                const drop = rainDrops[i];
                drop.y += drop.speed;
                drop.x += 0.5;
                
                if (drop.y > canvas.height + 20) {
                    rainDrops.splice(i, 1);
                }
            }
        }

        function drawRain() {
            ctx.save();
            ctx.strokeStyle = 'rgba(150, 200, 255, 0.6)';
            ctx.lineWidth = Math.max(1, rainSize * 0.1);
            
            for (const drop of rainDrops) {
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 2, drop.y + drop.length);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function updateSnow() {
            if (!snowEnabled) return;
            
            const spawnRate = Math.floor(snowIntensity);
            
            for (let i = 0; i < spawnRate; i++) {
                if (Math.random() < 0.2) {
                    snowFlakes.push({
                        x: Math.random() * canvas.width,
                        y: -10,
                        speed: snowSpeed * (0.5 + Math.random() * 0.5),
                        size: snowSize + Math.random() * (snowSize * 0.5),
                        drift: (Math.random() - 0.5) * 0.5
                    });
                }
            }
            
            for (let i = snowFlakes.length - 1; i >= 0; i--) {
                const flake = snowFlakes[i];
                flake.y += flake.speed;
                flake.x += flake.drift + Math.sin(flake.y * 0.01) * 0.3;
                
                if (flake.y > canvas.height + 20) {
                    snowFlakes.splice(i, 1);
                }
            }
        }

        function drawSnow() {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            
            for (const flake of snowFlakes) {
                ctx.beginPath();
                ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function updateHurricane() {
            if (!hurricane || !hurricane.active) return;
            
            hurricane.rotation += hurricaneSpeed * 0.04;
            
            const driftX = Math.sin(hurricane.rotation * 0.1) * hurricaneSpeed;
            const driftY = Math.cos(hurricane.rotation * 0.1) * (hurricaneSpeed * 0.6);
            
            hurricane.x += driftX;
            hurricane.y += driftY;
            
            if (hurricane.x < 0) hurricane.x = canvas.width;
            if (hurricane.x > canvas.width) hurricane.x = 0;
            if (hurricane.y < 0) hurricane.y = canvas.height;
            if (hurricane.y > canvas.height) hurricane.y = 0;
        }

        function drawHurricane() {
            if (!hurricane) return;
            
            ctx.save();
            
            const centerX = hurricane.x;
            const centerY = hurricane.y;
            const radius = hurricaneSize;
            
            for (let layer = 0; layer < 4; layer++) {
                const layerRadius = radius * (0.15 + layer * 0.25);
                const layerAlpha = 0.6 - layer * 0.12;
                
                const gradient = ctx.createRadialGradient(centerX, centerY, layerRadius * 0.3, centerX, centerY, layerRadius);
                if (layer === 0) {
                    gradient.addColorStop(0, `rgba(200, 200, 220, ${layerAlpha})`);
                    gradient.addColorStop(0.3, `rgba(180, 180, 200, ${layerAlpha * 0.9})`);
                    gradient.addColorStop(0.6, `rgba(160, 160, 180, ${layerAlpha * 0.7})`);
                    gradient.addColorStop(1, 'rgba(140, 140, 160, 0)');
                } else if (layer === 1) {
                    gradient.addColorStop(0, `rgba(180, 190, 210, ${layerAlpha})`);
                    gradient.addColorStop(0.4, `rgba(160, 170, 190, ${layerAlpha * 0.8})`);
                    gradient.addColorStop(0.8, `rgba(140, 150, 170, ${layerAlpha * 0.6})`);
                    gradient.addColorStop(1, 'rgba(120, 130, 150, 0)');
                } else if (layer === 2) {
                    gradient.addColorStop(0, `rgba(160, 170, 190, ${layerAlpha})`);
                    gradient.addColorStop(0.5, `rgba(140, 150, 170, ${layerAlpha * 0.7})`);
                    gradient.addColorStop(1, 'rgba(120, 130, 150, 0)');
                } else {
                    gradient.addColorStop(0, `rgba(140, 150, 170, ${layerAlpha})`);
                    gradient.addColorStop(0.6, `rgba(120, 130, 150, ${layerAlpha * 0.6})`);
                    gradient.addColorStop(1, 'rgba(100, 110, 130, 0)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, layerRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const eyeRadius = radius * 0.15;
            const eyeGradient = ctx.createRadialGradient(centerX, centerY, eyeRadius * 0.3, centerX, centerY, eyeRadius);
            eyeGradient.addColorStop(0, 'rgba(220, 230, 240, 0.8)');
            eyeGradient.addColorStop(0.5, 'rgba(200, 210, 220, 0.6)');
            eyeGradient.addColorStop(1, 'rgba(180, 190, 200, 0)');
            
            ctx.fillStyle = eyeGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            
            for (let band = 0; band < 3; band++) {
                const bandRadius = radius * (0.3 + band * 0.25);
                const bandSpacing = Math.PI / 12;
                
                for (let i = 0; i < 20; i++) {
                    const baseAngle = (hurricane.rotation * 1.5 + (i * bandSpacing)) % (Math.PI * 2);
                    const spiralTurns = 1.5;
                    const startRadius = bandRadius * 0.4;
                    const endRadius = bandRadius;
                    
                    ctx.strokeStyle = `rgba(180, 190, 210, ${0.5 - band * 0.1 - i * 0.015})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = 'rgba(150, 160, 180, 0.4)';
                    
                    ctx.beginPath();
                    for (let r = startRadius; r < endRadius; r += 3) {
                        const angle = baseAngle + (r / bandRadius) * Math.PI * spiralTurns;
                        const x = centerX + Math.cos(angle) * r;
                        const y = centerY + Math.sin(angle) * r;
                        if (r === startRadius) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function updateEarthquake() {
            if (!earthquakeEnabled) return;
            
            earthquakeTimer++;
            
            if (earthquakeTimer > (30 / earthquakeSpeed)) {
                earthquakeTimer = 0;
                earthquakeShake.x = (Math.random() - 0.5) * earthquakeIntensity * 2;
                earthquakeShake.y = (Math.random() - 0.5) * earthquakeIntensity * 2;
            } else {
                earthquakeShake.x *= 0.9;
                earthquakeShake.y *= 0.9;
            }
        }

        window.addEventListener('resize', () => {
            if (!applicationStarted) return;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            vhsCanvas.width = canvas.width;
            vhsCanvas.height = canvas.height;
        });
    </script>
</body>
</html>
